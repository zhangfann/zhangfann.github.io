(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{479:function(e,s,a){"use strict";a.r(s);var n=a(42),t=Object(n.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("跟着 LevelDB 学 C++，跟着 Rocksdb 学引擎。看完这一篇，你会对这一句话有更加深刻的理解。")]),e._v(" "),a("p",[e._v("LevelDB 能够教给你关于 C++ 语言本身很多的知识，如何写好 C++ 代码，如何让你掌握面向对象的核心编程思想。而 Rocksdb 则会交给你足够多的系统知识，优秀的存储引擎需要对上层应用以及底层的操作系统有非常深入的了解，这样我们才能够通过引擎提供足够的可靠性 / 易用性的同时 将操作系统 以及 底层硬件性能发挥到极致。")]),e._v(" "),a("p",[e._v("下面提到的关于 Rocksdb 的链路优化可能之前的博文中已经描述过了， 会做一个概览描述。")]),e._v(" "),a("h2",{attrs:{id:"_1-读链路"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-读链路"}},[e._v("#")]),e._v(" 1. 读链路")]),e._v(" "),a("h3",{attrs:{id:"_1-1-fileindexer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-fileindexer"}},[e._v("#")]),e._v(" 1.1 FileIndexer")]),e._v(" "),a("p",[e._v("对于 LSM-tree 的 Get 链路 会执行如下的一些搜索过程：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("memtable::Get` --\x3e `immutable::Get` --\x3e `table->Get\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("在前面的部分，如果拿到了 key-value 那就直接返回，拿不到，就每一步执行。对于 "),a("code",[e._v("table->Get")]),e._v("的逻辑，其实就是从 sst 中读，读到的结果会 load 到 block_cache，读的过程则是 按照"),a("code",[e._v("LEVEL")]),e._v(" 进行。"),a("code",[e._v("L0")]),e._v("因为是 tierd compaction 策略，LSM-tree 允许其有重叠 key，则需要在每一个文件中进行查找；如果没找到，则对大于 L0 的文件，按层查找。")]),e._v(" "),a("p",[e._v("我们要讨论的"),a("code",[e._v("FileIndexer")]),e._v("的主要功能是 Rocksdb 对于这个查找过程的优化，介绍 Rocksdb 的查找过程之前，我们肯定是先需要了解一下 LevelDB 的查找逻辑。")]),e._v(" "),a("h3",{attrs:{id:"_1-1-1-leveldb-sst-查找实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-1-leveldb-sst-查找实现"}},[e._v("#")]),e._v(" 1.1.1 LevelDB sst 查找实现")]),e._v(" "),a("p",[e._v("对于 LSM-tree 来说，生成的每一个 sst 文件都会在内存中维护一个 FileMeta，存放在这个 sst 对应的 version 之中。")]),e._v(" "),a("p",[a("code",[e._v("FileMeta")]),e._v("数据结构如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("struct FileMetaData {\n  FileMetaData() : refs(0), allowed_seeks(1 << 30), file_size(0) {}\n\n  int refs;\n  int allowed_seeks;  // Seeks allowed until compaction\n  uint64_t number;\n  uint64_t file_size;    // File size in bytes\n  InternalKey smallest;  // Smallest internal key served by table\n  InternalKey largest;   // Largest internal key served by table\n};\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br")])]),a("p",[e._v("因为 key 在单个 sst 文件中是有序的， 所以 FileMeta 中只需要保存关键的"),a("code",[e._v("smallest")]),e._v("和"),a("code",[e._v("largest")]),e._v("即可，这两个变量也是我们文件查找过程的关键。")]),e._v(" "),a("p",[e._v("因为 "),a("code",[e._v("L0")]),e._v("的每一个文件都要查找，那就需要看当前 key 是否在每一个 sst 文件的 range 中。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("tmp.reserve(files_[0].size());\nfor (uint32_t i = 0; i < files_[0].size(); i++) {\n  FileMetaData* f = files_[0][i];\n  if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&\n      ucmp->Compare(user_key, f->largest.user_key()) <= 0) {\n    // user key在当前 file中，则添加当前file 到数组中\n    tmp.push_back(f);\n  }\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br")])]),a("p",[e._v("对大于"),a("code",[e._v("L0")]),e._v("的文件，LevelDB 这里做的是整层进行二分查找，找到文件之后返回文件的 id 即可。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('int FindFile(const InternalKeyComparator& icmp,\n             const std::vector<FileMetaData*>& files, const Slice& key) {\n  uint32_t left = 0;\n  uint32_t right = files.size();\n  while (left < right) {\n    uint32_t mid = (left + right) / 2;\n    const FileMetaData* f = files[mid];\n    if (icmp.InternalKeyComparator::Compare(f->largest.Encode(), key) < 0) {\n      // Key at "mid.largest" is < "target".  Therefore all\n      // files at or before "mid" are uninteresting.\n      left = mid + 1;\n    } else {\n      // Key at "mid.largest" is >= "target".  Therefore all files\n      // after "mid" are uninteresting.\n      right = mid;\n    }\n  }\n  return right;\n}\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br")])]),a("p",[e._v("二分本身的比较逻辑是 O(logn) 的时间复杂度，对于 LSM-tree 来说，实际大数据量的情况下大多数的文件是存储在最底层。加入 L1=256M，到第五层的时候是 2T，每一个文件 64M 来算，到第五层会有接近 4w 个文件，那随机查找的时候，每一个 Get 大多情况下都会落到最后一层，也就意味着从 L0--\x3eL5 至少 20 次的比较，对 cpu 来说可谓是一个非常大的负担了。")]),e._v(" "),a("p",[e._v("rocksdb 这里利用文件有序这个特性来尝试减少 整层二分比较的次数。")]),e._v(" "),a("h3",{attrs:{id:"_1-1-2-rocksdb-fileindexer-实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-2-rocksdb-fileindexer-实现"}},[e._v("#")]),e._v(" 1.1.2 Rocksdb FileIndexer 实现")]),e._v(" "),a("p",[e._v("L0 每一个文件的查找还是避免不了，如果 user_key 在 L0 某一个文件的 range 内又不在这个文件中，这里 rocksdb 会基于当前文件 通过 FileIndexer 构造其接下来要查找的下一层文件的文件 range。")]),e._v(" "),a("p",[e._v("我们详细看看 FileIndexer 具体会做一些什么：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://pic3.zhimg.com/v2-663d68b77bc99b83fe2bb5f0b56f999a_r.jpg",alt:"img"}})]),e._v(" "),a("p",[e._v("拿着"),a("code",[e._v("LN")]),e._v(" 文件的"),a("code",[e._v("smallest_key")]),e._v(" 和 "),a("code",[e._v("largest_key")]),e._v("，构造其 "),a("code",[e._v("IndexUnit")]),e._v("，也就是四个变量:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("smallest_lb")]),e._v("，smallest_key 的左边界最有可能包含 F1 range 内 的 文件编号")]),e._v(" "),a("li",[a("code",[e._v("smallest_rb")]),e._v("，smallest_key 的右边界 最有可能包含 F1 range 内 的 文件编号")]),e._v(" "),a("li",[a("code",[e._v("largest_lb")]),e._v("，largest_key 的左边界 同上")]),e._v(" "),a("li",[a("code",[e._v("largest_rb")]),e._v(", largest_key 的右边界 同上")])]),e._v(" "),a("p",[e._v("因为大于 L0 的文件会整层都不会有 key-range 重叠，我们的 user_key 假如落在了 F1 上，那就可以根据上面的四个变量来划分接下来在"),a("code",[e._v("LN+1")]),e._v("的文件的查找区间。")]),e._v(" "),a("p",[e._v("比如：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("1. user_key < smallest_key\nsmallest_lb=1 查找的file_range [0,1]，如果F1的文件编号就是0，那smallest_lb 也就是0了。\n2. user_key > smallest_key && user_key < largest_key\nsmallest_rb=2;largest_lb=4 查找的file_range [2,4]，也就是在smallest_rb和largest_lb之间\n3. user_key > largest_key\nlargest_rb=5, 查找的file_range 会在[6,7]之间\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br")])]),a("p",[e._v("大多数的查找场景中，当我们 user_key 锁定"),a("code",[e._v("LN")]),e._v("的一个 file_range 的时候，这个 user_key 大概率是在"),a("code",[e._v("LN+1")]),e._v("的 [smallest_rb,largest_lb] 的 range 之间。")]),e._v(" "),a("p",[e._v("可以看到，我们有了每一个文件的 FileIndexer，这样就能够在查找的过程中极大得减少比较的次数。这种 FileIndexer 的查找过程 key 之间的比较次数完全是可控的 l，对于 Ln 的一个文件，在 Ln+1 中 key_range 的放大系数为 10，也就是平均只需要 log10 = 3 次比较。相比于 LevelDB 的整层二分查找，尤其是在最后一层的十几次比较，可以说是极大得减少了文件查找所需要的 CPU。")]),e._v(" "),a("p",[e._v("当然，这里需要注意的是 FileIndexer 的构造也需要消耗一定的 CPU。")]),e._v(" "),a("p",[e._v("构造部分的逻辑会每一次有新的 sst 文件生成的时候 以及 DB 重启 的时候触发：")]),e._v(" "),a("ul",[a("li",[e._v("DB 重启，"),a("code",[e._v("Recover")]),e._v("的时候调用"),a("code",[e._v("Version::PrepareApply")]),e._v(" 来进行构造")]),e._v(" "),a("li",[e._v("Compaction/Flush 完成之后 :")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  // Flush 完成之后\n  TryInstallMemtableFlushResults\n    LogAndApply\n    \tProcessManifestWrites\n    \t\tPrepareApply\n    \t\t\tGenerateFileIndexer\n  // Compaction完成之后\n  BackGroundCompaction\n    LogAndApply\n    \tProcessManifestWrites\n    \t\tPrepareApply\n    \t\t\tGenerateFileIndexer\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br")])]),a("p",[e._v("构造 Indexer 的过程肯定会拖慢整个 Flush 或者 Compaction 的效率，但是他们是后台线程，且触发的次数相比于我们实际 workload 下的 read-heavy 来说实在是微不足道，那通过这一点构造时候的 CPU 消耗来极大得减少我们 read-heavy 时的 CPU 消耗，还是非常值的。")]),e._v(" "),a("h3",{attrs:{id:"_1-2-pinnableslice-减少内存拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-pinnableslice-减少内存拷贝"}},[e._v("#")]),e._v(" 1.2 PinnableSlice 减少内存拷贝")]),e._v(" "),a("p",[e._v("先来看一下 LevelDB 的 Get 接口：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Status Get(const ReadOptions& options, const Slice& key,\n           std::string* value) override;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("这个"),a("code",[e._v("std::string")]),e._v("的 value 变量在后续从 sst 中读到数据之后会复制拷贝到这个 value 变量中。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("struct Saver {\n  SaverState state;\n  const Comparator* ucmp;\n  Slice user_key;\n  std::string* value; // 后续要返回给用户的变量\n};\n}  // namespace\nstatic void SaveValue(void* arg, const Slice& ikey, const Slice& v) {\n  Saver* s = reinterpret_cast<Saver*>(arg);\n  ParsedInternalKey parsed_key;\n  if (!ParseInternalKey(ikey, &parsed_key)) {\n    s->state = kCorrupt;\n  } else {\n    if (s->ucmp->Compare(parsed_key.user_key, s->user_key) == 0) {\n      s->state = (parsed_key.type == kTypeValue) ? kFound : kDeleted;\n      if (s->state == kFound) {\n        // 内存拷贝\n        s->value->assign(v.data(), v.size());\n      }\n    }\n  }\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br"),a("span",{staticClass:"line-number"},[e._v("21")]),a("br"),a("span",{staticClass:"line-number"},[e._v("22")]),a("br")])]),a("p",[e._v("这个时候就会发生内存拷贝。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://pic4.zhimg.com/v2-4a4f1cbe7af135caad48a17583b41d7b_r.jpg",alt:"img"}})]),e._v(" "),a("p",[e._v("上图就是 Rocksdb 在早期版本的实现，也就是 leveldb 的 std::string 透传到底层，通过内存拷贝拿到数据之后再返回给用户。")]),e._v(" "),a("p",[e._v("内存拷贝涉及到数据从旧的地址中搬移到新的地址，那这个过程会申请新的内存，释放旧的内存。尤其是在我们读 heavy 且实际数据量远超内存的场景下，频繁申请内存 / 释放内存 (内核缺页 -》回收页面 --》分配新页面) 以及 数据的拷贝对 内存以及 CPU 都是不小的负担，这个痛点也是所有做底层软件需要尽可能避免的问题。（当然，前提是其他的数据结构 / 存储上的 优化已经足够细致了，瓶颈可能会在这里）")]),e._v(" "),a("p",[e._v("那现在版本的 Rocksdb 为了追求极致性能，肯定会对这一部分进行优化的。")]),e._v(" "),a("p",[e._v("直接看下图：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://pic1.zhimg.com/v2-355188f64eef436168390350c678084c_r.jpg",alt:"img"}})]),e._v(" "),a("p",[e._v("Rocksdb 这里优化的部分就是在第三步的时候 从 sst 中拿到 BlockContents 之后 不会直接将其中的 value 填给用户传下来的变量，而是将拿到的这个 value 的地址给这个变量。")]),e._v(" "),a("p",[e._v("这里我们会从逻辑中发现一个潜在的问题，实际填充给用户的是读上来的 value 的地址。逻辑如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("BlockBasedTable::Get\n  BlockBasedTable::NewDataBlockIterator // 构造DataBlockIter\n    GetContext::SaveValue // 将DataBlockIter 的value内容填充给用户\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("但是 BlockBasedTable 通过 DataBlockIter 拿到的 value 结果是要填充给 BlockCache 的。那填充完成之后当前的 DataBlockIter 是需要被释放的，释放则意味着用户拿到的地址空间就不存在了。")]),e._v(" "),a("p",[e._v("有没有办法让这个 DataBlockIter 的释放能够延迟一段时间，到上层 Get 用户已经取到了这个 value 之后再释放呢。")]),e._v(" "),a("p",[e._v("来看一下 rocksdb 使用的获取实际 value 的类 "),a("code",[e._v("PinnableSlice")]),e._v(" 以及 能够延迟 DataBlockIter 生命周期的类"),a("code",[e._v("Cleanable")]),e._v("。")]),e._v(" "),a("p",[e._v("对于"),a("code",[e._v("PinnableSlice")]),e._v("来说继承"),a("code",[e._v("Slice")]),e._v("，也就能够通过"),a("code",[e._v("data_")]),e._v("来缓存实际数据。它提供了一系列基于"),a("code",[e._v("Cleanable")]),e._v("类的成员函数实现的函数。所以，我们主要看一下"),a("code",[e._v("Cleanable")]),e._v("这个类是如何让 PinnableSlice 拿到的地址延迟释放呢。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class PinnableSlice : public Slice, public Cleanable {\n    ......\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("Cleanable 类的成员如下：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://pic2.zhimg.com/v2-69eeaca98923eaa70dfa4585e0a473d5_r.jpg",alt:"img"}})]),e._v(" "),a("p",[e._v("其中的私有成员主要是维护了一个"),a("code",[e._v("Cleanup")]),e._v("类，这个类用来保存执行具体逻辑的部分，包括函数指针以及两个参数，同时还维护了一个单链表。")]),e._v(" "),a("p",[e._v("那我们具体看看"),a("code",[e._v("Cleanable")]),e._v("类的成员函数 之间是如何和"),a("code",[e._v("Cleanup")]),e._v("一起延长一个类的生命周期的。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("void Cleanable::RegisterCleanup(CleanupFunction func, void* arg1, void* arg2) {\n  assert(func != nullptr);\n  Cleanup* c;\n  if (cleanup_.function == nullptr) {\n    c = &cleanup_;\n  } else {\n    c = new Cleanup;\n    c->next = cleanup_.next;\n    cleanup_.next = c;\n  }\n  c->function = func;\n  c->arg1 = arg1;\n  c->arg2 = arg2;\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br")])]),a("p",[e._v("可以看到在 RegisterCleanup 中，将需要 register 的函数指针和参数 创建一个新的"),a("code",[e._v("Cleanup")]),e._v("对象，添加到当前"),a("code",[e._v("Cleanable")]),e._v("类的"),a("code",[e._v("cleanup_")]),e._v("之前。")]),e._v(" "),a("p",[e._v("大体过程如下图：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://pic4.zhimg.com/v2-12d0aae2eca5ceef3da03fbc5cb88e1b_r.jpg",alt:"img"}})]),e._v(" "),a("p",[e._v("有两个"),a("code",[e._v("Cleanable")]),e._v("对象，如果 C1 想要注册一个 cleanup 对象，传入函数指针和参数，那就会构造一个新的 cleanup 对象，使用链表头插法插入到 C1 维护的 cleanup 对象链表中。")]),e._v(" "),a("p",[e._v("在 Cleanable 对象析构的时候可以调用它的析构函数，执行"),a("code",[e._v("DoCleanup")]),e._v("逻辑")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Cleanable::~Cleanable() { DoCleanup(); }\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("执行如下函数的逻辑：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("inline void DoCleanup() {\n  if (cleanup_.function != nullptr) {\n    (*cleanup_.function)(cleanup_.arg1, cleanup_.arg2);\n    for (Cleanup* c = cleanup_.next; c != nullptr;) {\n      (*c->function)(c->arg1, c->arg2);\n      Cleanup* next = c->next;\n      delete c;\n      c = next;\n    }\n  }\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br")])]),a("p",[e._v("按照顺序遍历链表，执行 cleanup 对象中的函数，从头执行到尾巴。")]),e._v(" "),a("p",[e._v("如果将 Cleanable 对象 C1 通过"),a("code",[e._v("DelegateCleanupsTo")]),e._v("委托给 C2，我们看看会发生什么：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://pic2.zhimg.com/v2-946c47076fcb8f8b7d1997ab89940e69_r.jpg",alt:"img"}})]),e._v(" "),a("p",[e._v("大体的过程就是将 C1 对象中的 cleanup 对象逐个取出来，头插法插入到 C2 维护的 cleanup 对象的链表中。")]),e._v(" "),a("p",[e._v("这样，C1 委托给 C2 之后，C2 在最后析构的时候就按照顺序执行所有的 C1 的资源释放逻辑，是不是非常巧妙。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("void Cleanable::DelegateCleanupsTo(Cleanable* other) {\n  assert(other != nullptr);\n  if (cleanup_.function == nullptr) {\n    return;\n  }\n  // 先将当前的cleanup 成员 转交给other\n  Cleanup* c = &cleanup_;\n  other->RegisterCleanup(c->function, c->arg1, c->arg2);\n  c = c->next;\n  // 如果cleanup链表还有成员，则逐个遍历，挨个转交\n  while (c != nullptr) {\n    Cleanup* next = c->next;\n    other->RegisterCleanup(c);\n    c = next;\n  }\n  // 最后清理当前对象\n  cleanup_.function = nullptr;\n  cleanup_.next = nullptr;\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br")])]),a("p",[e._v("我们可以看一个简单的 Cleanable 类的使用方式，如下测试代码：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('void Multiplier(void* arg1, void* arg2) {\n  int* res = reinterpret_cast<int*>(arg1);\n  int* num = reinterpret_cast<int*>(arg2);\n  *res *= *num;\n}\n\nint main() {\n  int n2 = 2;\n  int res = 1;\n  {\n    Cleanable c2;\n    {\n      Cleanable c1;\n      c1.RegisterCleanup(Multiplier, &res, &n2); \n      c1.DelegateCleanupsTo(&c2);\n    }\n    // ~Cleanable c1 ，res = 1\n    std::cout << "Delete c1, res is : " << res << std::endl;\n  }\n  // ~Cleanable c2 , res = 2\n  std::cout << "Delete c2, res is : " << res << std::endl;\n}\n\n// output\nDelete c1, res is : 1\nDelete c2, res is : 2\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br"),a("span",{staticClass:"line-number"},[e._v("21")]),a("br"),a("span",{staticClass:"line-number"},[e._v("22")]),a("br"),a("span",{staticClass:"line-number"},[e._v("23")]),a("br"),a("span",{staticClass:"line-number"},[e._v("24")]),a("br"),a("span",{staticClass:"line-number"},[e._v("25")]),a("br"),a("span",{staticClass:"line-number"},[e._v("26")]),a("br")])]),a("p",[e._v("当执行 C2 的析构的时候 才会执行 Multiplier 中的逻辑，因为 C1 将注册的 Multiplier 转交给了 C2，如果没有转交，则第一个输出的内容就是 2 了。")]),e._v(" "),a("p",[e._v("通过 Cleanable 对象的特性，我们回到解决内存拷贝问题中的 PinnableSlice 中，就可以让 DataBlockIter 和 PinnbaleSlice 都继承 "),a("code",[e._v("Cleanable")]),e._v("类，这样在将 DataBlockIter 的地址交给 PinnableSlice 的时候就可以将其释放逻辑也转交给 PinnableSlice，用户层拿到了想要的 value 之后 析构 PinnableSlice 的时候再释放 DataBlockIter 就好了。")]),e._v(" "),a("p",[e._v("这里的地址赋值 以及 转交逻辑如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("BlockBasedTable::Get \n  GetContext::SaveValue //构造好的DataBlockIter 的 value 地址进行传入进去\n    PinSlice\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("最终的转交链路如下：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://pic3.zhimg.com/v2-10ade6685ab46202b3df2f8098ce5dfa_r.jpg",alt:"img"}})]),e._v(" "),a("p",[e._v("BlockIter 和 PinnableSlice 都是继承了 Cleannable 类，他们在初始化的时候都会注册一个自己释放空间的逻辑，在通过迭代器读取到了数据之后会将 BlockIter 委托给 PinnableSlice 对象，委托的过程就是让 PinnableSlice 的 data_指针指向 BlockData 的地址。")]),e._v(" "),a("h3",{attrs:{id:"_1-3-cache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-cache"}},[e._v("#")]),e._v(" 1.3 Cache")]),e._v(" "),a("h3",{attrs:{id:"_1-3-1-lru-cache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-1-lru-cache"}},[e._v("#")]),e._v(" 1.3.1 LRU Cache")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/Z_Stand/article/details/118832473?spm=1001.2014.3001.5501",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rocksdb 工业级 LRU Cache 实现"),a("OutboundLink")],1)]),e._v(" "),a("h3",{attrs:{id:"_1-3-2-clock-cache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-2-clock-cache"}},[e._v("#")]),e._v(" 1.3.2 Clock Cache")]),e._v(" "),a("p",[e._v("LRU Cache 在并发场景并不是很友好，所以 Rocksdb 推出了 clock cache，在高并发下更加有优势。")]),e._v(" "),a("p",[e._v("先看一下 Clock Cache 的大体架构图：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://pic4.zhimg.com/v2-661d32a08ee1f93913153aaabdf1afff_r.jpg",alt:"img"}})]),e._v(" "),a("p",[e._v("Clock Cache 同样是分 shard，外部做了一层 hash，基本组件如下：")]),e._v(" "),a("ul",[a("li",[e._v("Concurrent HashMap，用来缓存 key 以及 value-handle。这里为了对并发友好一些，hashmap 使用的是 TBB 的 concurrent_hash_map")]),e._v(" "),a("li",[e._v("Circle List，这个数据结构主要是为 实现 clock 算法用的。Rocksdb 这里使用的是 Deque + head 索引实现环形链表的功能。即通过 head 进行 deque 的遍历， 遍历的过程中遍历到 deque 的末尾的时候让 head 重新指向 deque 的头部。")]),e._v(" "),a("li",[e._v("Recycle bin，一个保存从 Deque 中淘汰节点的数组。用于后续有新的节点加入的时候先从 recycle bin 中直接取可以插入的位置即可，不需要重新申请存储空间。")])]),e._v(" "),a("p",[e._v("Clock 算法的淘汰原理就是针对存储在环形链表中的每一个节点维护两个属性： Access 和 Modify，当 clock cache 满了之后需要进行节点的淘汰， 这个时候会循环遍历环形链表，发现每个节点的两个属性满足以下要求时就进行淘汰。")]),e._v(" "),a("ol",[a("li",[e._v("A = 0 ，M = 0; 即没有被访问过，也没有被修改过，则优先淘汰。")]),e._v(" "),a("li",[e._v("A = 0，M = 1; 没有被访问过， 被修改过，则第一次遍历会将这个属性置为 0，第二次遍历遇到这种情况就可以直接被淘汰。")]),e._v(" "),a("li",[e._v("A = 1, M = 0; 被访问过，没有被修改过，则第一次遍历同样会将访问过的属性置 0， 第二次遍历再进行清理。")]),e._v(" "),a("li",[e._v("A = 1, M = 1; 被放过，也被修改过。第一次遍历不会被淘汰。")])]),e._v(" "),a("p",[e._v("淘汰的时候会优先选择淘汰第一种情况，对第二种情况进行置位以便下次淘汰，对第三和第四种情况进行访问计数自减，知道访问计为 0 的时候才会淘汰。")]),e._v(" "),a("p",[e._v("而 rocksdb 实现的 ClockCache 的算法大体接近，只是多了一些属性（incache, usage, reference_count ）只有当 reference_count=1 且 incache=1 时才会进行淘汰，否则淘汰的时候会将这一些属性的计数自减。")]),e._v(" "),a("p",[e._v("Clock Cache 相比于 LRUCache 的优势主要有以下两种：")]),e._v(" "),a("ol",[a("li",[e._v("ClockCache 的节点淘汰并不会直接从 环形链表中删除释放节点，而是将淘汰的节点放在 Recycle bin 数组中，不像 LRU cache 的淘汰需要操作双向链表的删除以及节点释放。")]),e._v(" "),a("li",[e._v("ClockCache 在 Erase 的时候，可以使用 tbb-hashtable 的 并发 erase 优势。")])]),e._v(" "),a("p",[e._v("但是 ClockCache 在 insert 的时候也会加锁，所以 cache insert 部分的优势相比于 Lru 基本没有，lookup 的时候是无锁的（不涉及数据结构的变更，不需要加锁），所以整体上来看 ClockCache 在 lookup 以及 erase 的比例比较高的时候性能是比 LRU cache 有优势的，但是 insert 比例比较高的时候基本就没有什么优势了。")]),e._v(" "),a("p",[e._v("使用"),a("code",[e._v("cache_bench")]),e._v(" 工具进行测试可以比较明显得看到这两种 Cache 在不通 workload 下的性能差异：")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Insert 80%")]),e._v(", lookup 10%, erase 10%, threads 32, shards 32;")])]),e._v(" "),a("p",[e._v("LRU : 305w/s, Clock: 203w/s")]),e._v(" "),a("ul",[a("li",[e._v("Insert 10%, lookup 10%, "),a("strong",[e._v("erase 80%")]),e._v(", threads 32, shards 32;")])]),e._v(" "),a("p",[e._v("LRU: 697w/s, Clock: 1173w/s")]),e._v(" "),a("ul",[a("li",[e._v("Insert 10%, "),a("strong",[e._v("lookup 80%")]),e._v(", erase 10%, threads 32, shards 32")])]),e._v(" "),a("p",[e._v("LRU: 681w/s, Clock: 1137w/s")]),e._v(" "),a("p",[e._v("当然，实际应用过程中对 cache 的操作是一个复杂过程，与 workload 强相关，比如 Put 比例多且 cache 大小远小于实际的磁盘数据量时，则 cache 的 insert 比例都会比较高（compaction 导致的 cache 失效回填），而且这种情况下的 Get 的 key_range 也是完全随机的话 lookup 和 insert 比例都会比较高。而对于热点场景，大多数是 lookup 的情况可能 Clockcache 会更有优势一些。")]),e._v(" "),a("h3",{attrs:{id:"_1-4-threadlocalptr-线程私有存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-threadlocalptr-线程私有存储"}},[e._v("#")]),e._v(" 1.4 ThreadLocalPtr 线程私有存储")]),e._v(" "),a("p",[e._v("线程私有存储是 Rocksdb 为 version 系统推出的一种访问模型，能够最大程度得实现无锁访问，从而加速整个引擎的读 / 写 / compaction 的效率。了解线程私有存储之前我们需要先了解一下 Rocksdb 的 version 系统，从而能够整体看一下 Rocksdb 的 key/value 的读写操作模型。")]),e._v(" "),a("h3",{attrs:{id:"_1-4-1-version-系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-1-version-系统"}},[e._v("#")]),e._v(" 1.4.1 version 系统")]),e._v(" "),a("p",[e._v("整个 version 系统的架构及关系图如下：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://pic3.zhimg.com/v2-770d5cb7df3a1061f1f00d3f7ba1fd82_r.jpg",alt:"img"}})]),e._v(" "),a("p",[e._v("当我们 Get 或者 Seek 的时候，针对都会从当前 cf 先拿到一个 SuperVersion，通过这个 sv 来访问对应的 mem/imm/version。访问 version 的时候会直接拿当前的 current 取其"),a("code",[e._v("versionStorageInfo")]),e._v("，current 会指向双向链表维护的最新的 version，再去拿到对应的 sst 文件元信息去索引对应的文件（FileMeta）。")]),e._v(" "),a("p",[e._v("像我们的"),a("code",[e._v("Rocksdb::GetImpl")]),e._v("接口，不论是去读 memtable 或者 immutable 或者 sst 的都会先拿到 sv，再去具体读对应的 value：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Status DBImpl::GetImpl(const ReadOptions& read_options,\n                       ColumnFamilyHandle* column_family, const Slice& key,\n                       PinnableSlice* pinnable_val, bool* value_found,\n                       ReadCallback* callback, bool* is_blob_index) {\n  ...\n  // 获取当前的superversion\n  SuperVersion* sv = GetAndRefSuperVersion(cfd);\n  ...\n  // 读memtable\n  if (sv->mem->Get(lkey, pinnable_val->GetSelf(), &s, &merge_context,\n                     &max_covering_tombstone_seq, read_options, callback,\n                     is_blob_index)) {\n    ...\n  }\n  // 读immutable \n  sv->imm->Get(lkey, pinnable_val->GetSelf(), &s, &merge_context,\n                            &max_covering_tombstone_seq, read_options, callback,\n                            is_blob_index)) {\n  ...\n  }\n  // 读sst\n  sv->current->Get(read_options, lkey, pinnable_val, &s, &merge_context,\n                   &max_covering_tombstone_seq, value_found, nullptr, nullptr,\n                   callback, is_blob_index);\n  ...\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br"),a("span",{staticClass:"line-number"},[e._v("21")]),a("br"),a("span",{staticClass:"line-number"},[e._v("22")]),a("br"),a("span",{staticClass:"line-number"},[e._v("23")]),a("br"),a("span",{staticClass:"line-number"},[e._v("24")]),a("br"),a("span",{staticClass:"line-number"},[e._v("25")]),a("br"),a("span",{staticClass:"line-number"},[e._v("26")]),a("br")])]),a("p",[e._v("如果从三个组件的任何一个能够读到，则会返回结果，并释放当前的 sv。")]),e._v(" "),a("p",[e._v("那接下来我们思考一下，针对 Rocksdb 的访问一定是并发的，比如并发"),a("code",[e._v("Get")]),e._v(" ，而 memtable/sst 都是时刻在变动的（不断得 Put 产生的 flush 和 compaction），那我们的一次 Get 想要保证读到最新的数据，一定会拿到最新的 version，如果没有太多的考虑， 针对 version 的访问需要锁的保护，防止读到更新的中间状态。在这种情况下，一旦有锁的参与，我们的性能将会巨差无比。")]),e._v(" "),a("p",[e._v("Rocksdb 为了提升高并发场景下针对 LSM-tree 各个组件的访问性能，减少锁的参与，引入了线程私有存储。")]),e._v(" "),a("h3",{attrs:{id:"_1-4-2-c-thread-local-vs-threadlocalptr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-2-c-thread-local-vs-threadlocalptr"}},[e._v("#")]),e._v(" 1.4.2 C++ thread_local vs ThreadLocalPtr")]),e._v(" "),a("p",[e._v("线程私有存储 就是让每一个线程都访问自己的存储内容，当然 C++ 本身也提供了线程私有存储的关键字（"),a("code",[e._v("thread_local")]),e._v("），当然 rocksdb 并没有选用，而是实现了一个更为复杂的"),a("code",[e._v("ThreadLocalPtr")]),e._v("。")]),e._v(" "),a("p",[e._v("先来看一下 Rocksdb 没有选用这个关键字的原因，如下"),a("code",[e._v("thread_local")]),e._v("的代码：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('#include <iostream>\n#include <thread>\n#include <unistd.h>\n\nclass A {\n public:\n  A() {}\n  ~A() {}\n\n  void test(const std::string &name) {\n    thread_local int count = 0;\n    ++count;\n    std::cout << name << ": " <<  count << std::endl;\n  }\n};\n\nvoid func(const std::string &name) {\n  A a1;\n  a1.test(name);\n  a1.test(name);\n  A a2;\n  a2.test(name);\n  a2.test(name);\n}\n\nint main(int argc, char* argv[]) {\n  std::thread t1(func, "t1");\n  t1.join();\n  std::thread t2(func, "t2");\n  t2.join();\n  return 0;\n}\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br"),a("span",{staticClass:"line-number"},[e._v("21")]),a("br"),a("span",{staticClass:"line-number"},[e._v("22")]),a("br"),a("span",{staticClass:"line-number"},[e._v("23")]),a("br"),a("span",{staticClass:"line-number"},[e._v("24")]),a("br"),a("span",{staticClass:"line-number"},[e._v("25")]),a("br"),a("span",{staticClass:"line-number"},[e._v("26")]),a("br"),a("span",{staticClass:"line-number"},[e._v("27")]),a("br"),a("span",{staticClass:"line-number"},[e._v("28")]),a("br"),a("span",{staticClass:"line-number"},[e._v("29")]),a("br"),a("span",{staticClass:"line-number"},[e._v("30")]),a("br"),a("span",{staticClass:"line-number"},[e._v("31")]),a("br"),a("span",{staticClass:"line-number"},[e._v("32")]),a("br")])]),a("p",[e._v("我们声明了类 "),a("code",[e._v("A")]),e._v("的成员函数"),a("code",[e._v("test")]),e._v("的访问时线程私有存储方式，然后在"),a("code",[e._v("func")]),e._v(" 中生成了两个对象， 按照我们正常的执行逻辑，两个对象的 test 函数的执行是各自输出各自的，也就是都输出 1；两个线程之间的执行互不影响。")]),e._v(" "),a("p",[e._v("而最终的输出结果：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("t1: 1\nt1: 2\nt1: 3\nt1: 4\nt2: 1\nt2: 2\nt2: 3\nt2: 4\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br")])]),a("p",[e._v("很明显的一个问题，"),a("code",[e._v("thread_local")]),e._v("声明了"),a("code",[e._v("count")]),e._v("之后，在当前线程的所有 A 对象会共享同一个变量，我们想要一个线程内部的同一个类不通对象之间不共享，则无法生效。")]),e._v(" "),a("p",[e._v("其次，"),a("code",[e._v("thread_local")]),e._v(" 无法区分不同的线程，上面的输出其实是通过外部标识了不同的线程，对于执行函数"),a("code",[e._v("func")]),e._v("来说，它完全无法区分当前执行的是哪一个线程。")]),e._v(" "),a("p",[e._v("因为这一些语言 (thread_local)/ 编译器(__thread) 本身的限制，Rocksdb 想要针对重要的 version 系统实现无锁化，就自己设计了"),a("code",[e._v("ThreadLocalPtr")]),e._v("。")]),e._v(" "),a("h3",{attrs:{id:"_1-4-3-threadlocalptr-设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-3-threadlocalptr-设计"}},[e._v("#")]),e._v(" 1.4.3 ThreadLocalPtr 设计")]),e._v(" "),a("p",[e._v("设计的初衷主要是线程私有存储的灵活性：")]),e._v(" "),a("ol",[a("li",[e._v("在同一个线程内部区分不同对象 (可能会有多个 sv 实例)。")]),e._v(" "),a("li",[e._v("在同一个进程内部区分不同的线程 (可能不同线程同时读写一个 sv)。")]),e._v(" "),a("li",[e._v("希望在一个线程内部能够清空或者重置所有线程的 tls")]),e._v(" "),a("li",[e._v("希望运行时再确定 tls 的类型，而"),a("code",[e._v("thread_local")]),e._v("和"),a("code",[e._v("__thread")]),e._v("都无法做到。")])]),e._v(" "),a("p",[e._v("Rocksdb 的 "),a("code",[e._v("ThreadLocalPtr")]),e._v(" 使用方式如下，非常简单（当然， 接口不止如下几个）：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// Define a variable\nThreadLocalPtr tls;\n\n// Write data\n// thread1\ntls.Reset(reinterpret_cast<int*>(1))\n// tls.Swap(reinterpret_cast<int*>(1)) // 和上面的效果是一样的\n// thread2\ntls.Reset(reinterpret_cast<int*>(2))\n\n// Get data\n// thread1\ntls.Get() == reinterpret_cast<int*>(1)\n// thread2\ntls.Get() == reinterpret_cast<int*>(2)\n\n// set all thread’s tls to null\ntls.Scrape(&ptrs, nullptr);\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br")])]),a("p",[e._v("整个"),a("code",[e._v("ThreadLocalPtr")]),e._v("的 类以及其相关类如下（不是标准的 UML 类图），大体能够看到其中各个成员之间的关系。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://pic4.zhimg.com/v2-ce9bc3f7444f5f68d0b0e03fa5cf314b_r.jpg",alt:"img"}})]),e._v(" "),a("p",[e._v("可以看到"),a("code",[e._v("ThreadLocalPtr")]),e._v(" 除了对外的成员函数接口之外主要是一个 "),a("code",[e._v("id_")]),e._v(" 以及 "),a("code",[e._v("StaticMeta::Instance()")]),e._v("私有成员。")]),e._v(" "),a("p",[e._v("而"),a("code",[e._v("StaticMeta")]),e._v(" 类中的主要成员 除了实现线程私有存储的 posix 类型"),a("code",[e._v("pthread_key_t")]),e._v("之外 还有一个"),a("code",[e._v("__thread")]),e._v("的"),a("code",[e._v("ThreadData")]),e._v("类型的私有成员"),a("code",[e._v("tls_")]),e._v("。")]),e._v(" "),a("p",[e._v("可以发现，我们实际的私有存储数据是存放在"),a("code",[e._v("ThreadData")]),e._v(" 之中的"),a("code",[e._v("Entry")]),e._v("之中，对于私有存储数据的管理是通过"),a("code",[e._v("ThreadData")]),e._v("维护的双向链表进行的。而且每一个"),a("code",[e._v("ThreadData")]),e._v("对象都会有一个共享的"),a("code",[e._v("ThreadLocalPtr::StaticMeta")]),e._v("对象。")]),e._v(" "),a("p",[e._v("而最外部的"),a("code",[e._v("ThreadLocalPtr")]),e._v("的"),a("code",[e._v("id_")]),e._v("则能够标识访问当前私有存储的线程。")]),e._v(" "),a("p",[e._v("接下来我们看一下创建一个 ThreadLocalPtr 对象，不同类之间的关系形态：")]),e._v(" "),a("ol",[a("li",[e._v("创建第一个"),a("code",[e._v("ThreadLocalPtr")]),e._v(" 对象 "),a("code",[e._v("local_1")])])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://pic4.zhimg.com/v2-08bfd930dec09cf60bb273245ebd1177_r.jpg",alt:"img"}})]),e._v(" "),a("p",[e._v("通过"),a("code",[e._v("Reset")]),e._v("接口，将创建好的"),a("code",[e._v("ThreadData")]),e._v(" 采用链表的尾插法，插入到"),a("code",[e._v("StaticMeta")]),e._v("维护的 ThreaData 类型的"),a("code",[e._v("head_")]),e._v("之后，形成一个双向循环链表，同时将 Reset 传入的"),a("code",[e._v("void*")]),e._v(" 类型的数据存储到"),a("code",[e._v("Entry")]),e._v("数组之中；标识下一个 ThreadLocalPtr 对象的 id 是 1。")]),e._v(" "),a("ol",[a("li",[e._v("创建第二个 "),a("code",[e._v("ThreadLocalPtr")]),e._v(" 对象"),a("code",[e._v("local_2")])])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://pic4.zhimg.com/v2-da91990f74db47d8e1cdef9c056c919f_r.jpg",alt:"img"}})]),e._v(" "),a("p",[e._v("创建的第二个私有存储变量"),a("code",[e._v("local_2")]),e._v(" 同样会创建一个"),a("code",[e._v("ThreadData")]),e._v("对象，采用双向链表的尾插法插入到"),a("code",[e._v("StaticMeta")]),e._v("维护的 双向循环链表中，并标识下一个"),a("code",[e._v("ThreadLocalPtr")]),e._v(" 实例的 id 是 2。")]),e._v(" "),a("p",[e._v("这样，我们有了一个全局的"),a("code",[e._v("StaticMeta")]),e._v("对象（对 StaticMeta 对象的创建是单例模式），通过它的双向循环链表"),a("code",[e._v("head_")]),e._v(" 能够访问到所有的创建的私有存储对象。每一个双向链表的节点"),a("code",[e._v("ThreadData")]),e._v("都保存了所有"),a("code",[e._v("ThreadLocalPtr")]),e._v("对象，访问具体的哪一个线程创建的 ThreadLocalPtr 对象则通过 "),a("code",[e._v("ThreadLocalPtr")]),e._v("的"),a("code",[e._v("id_")]),e._v("标识。")]),e._v(" "),a("p",[e._v("具体的访问以及创建 ThreadLocalPtr 对象的代码如下：")]),e._v(" "),a("ul",[a("li",[e._v("访问"),a("code",[e._v("ThreadLocalPtr")]),e._v(" 对象的代码"),a("code",[e._v("Get")]),e._v("：")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("c void* ThreadLocalPtr::StaticMeta::Get(uint32_t id) const { // 拿到全局StaticMeta 实例 的tls auto* tls = GetThreadLocal(); if (UNLIKELY(id >= tls->entries.size())) { return nullptr; } // 访问当前 线程的ThreadLocalPtr 的存储内容 return tls->entries[id].ptr.load(std::memory_order_acquire); }\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("ul",[a("li",[e._v("创建"),a("code",[e._v("ThreadLocalPtr")]),e._v(" 对象的代码"),a("code",[e._v("Reset")]),e._v("(存储的时候是松散内存序，可能不会立即同步到内存，仅仅同步到 cpu-cache 就返回了) / "),a("code",[e._v("Swap")]),e._v("(严格内存序，会从 cpu-cache 同步到内存)")])]),e._v(" "),a("p",[e._v("```c void ThreadLocalPtr::StaticMeta::Reset(uint32_t id, void "),a("em",[e._v("ptr) { // 拿到全局 StaticMeta 实例的 tls auto")]),e._v(" tls = GetThreadLocal(); if (UNLIKELY(id>= tls->entries.size())) { // Need mutex to protect entries access within ReclaimId MutexLock l(Mutex()); tls->entries.resize(id + 1); } // 松散内存序存储 tls->entries[id].ptr.store(ptr, std::memory_order_release); }")]),e._v(" "),a("p",[e._v("void "),a("em",[e._v("ThreadLocalPtr::StaticMeta::Swap(uint32_t id, void")]),e._v(" ptr) {auto* tls = GetThreadLocal(); if (UNLIKELY(id >= tls->entries.size())) { // Need mutex to protect entries access within ReclaimId MutexLock l(Mutex()); tls->entries.resize(id + 1); } // 严格内存序列内存 CAS return tls->entries[id].ptr.exchange(ptr, std::memory_order_acquire); } ```")]),e._v(" "),a("h3",{attrs:{id:"_1-4-4-threadlocalptr-在-version-系统中的应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-4-threadlocalptr-在-version-系统中的应用"}},[e._v("#")]),e._v(" 1.4.4 ThreadLocalPtr 在 version 系统中的应用")]),e._v(" "),a("p",[e._v("回到我们最初 version 系统中的"),a("code",[e._v("SuperVersion")]),e._v("，读取操作主要是依赖 superversion。Rocksdb 这里针对 SuperVersion 的操作主要提供了如下两个函数：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("InstallSuperVersion // 后台线程flush/compaction 完成之后会更新 全局的superversion 以及 清理所有的 tls superversion\nGetReferencedSuperVersion // 获取 local tls 的sv，如果过期了，则会重新从全局的sv中获取一个新的sv进行访问；否则直接拿到local 的 sv进行访问。\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("通过如下图能够非常清晰得看到 tls(thread local storage) 在 version 系统的重要作用。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://pic1.zhimg.com/v2-08cdaf493be25cc9c11d9c4423f02360_r.jpg",alt:"img"}})]),e._v(" "),a("p",[e._v("我们的"),a("code",[e._v("writer")]),e._v(" 和 "),a("code",[e._v("reader")]),e._v(" 可以看作是用户调用的"),a("code",[e._v("Put")]),e._v(" 和 "),a("code",[e._v("Get")]),e._v(" 操作，每一个操作代表一个并发线程。")]),e._v(" "),a("p",[e._v("Writer 操作会引入 flush 以及 compaction 操作，"),a("code",[e._v("BackGroundCompaction")]),e._v(" --\x3e "),a("code",[e._v("InstallSuperVersionAndScheduleWork")]),e._v(" --\x3e "),a("code",[e._v("InstallSuperVerion")]),e._v(" 的时候会先更新全局的"),a("code",[e._v("super_version_")]),e._v("，同时将所有的 tls sv 通过"),a("code",[e._v("ResetThreadLocalSuperVersions")]),e._v("设置为 obsolute。")]),e._v(" "),a("p",[e._v("代码如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("void ColumnFamilyData::ResetThreadLocalSuperVersions() {\n  autovector<void*> sv_ptrs;\n  // 对tls 的所有 ThreadLocalPtr 对象进行通知标记（读请求拿到的tls也能够感知到）\n  local_sv_->Scrape(&sv_ptrs, SuperVersion::kSVObsolete);\n  for (auto ptr : sv_ptrs) {\n    assert(ptr);\n    if (ptr == SuperVersion::kSVInUse) {\n      continue;\n    }\n    auto sv = static_cast<SuperVersion*>(ptr);\n    bool was_last_ref __attribute__((__unused__));\n    was_last_ref = sv->Unref();\n    // sv couldn't have been the last reference because\n    // ResetThreadLocalSuperVersions() is called before\n    // unref'ing super_version_.\n    assert(!was_last_ref);\n  }\n}\n\n// Scrape 的操作就是通过 StaticMeta 单例对象来遍历循环链表中的 tls存储，逐个标记\nvoid ThreadLocalPtr::StaticMeta::Scrape(uint32_t id, autovector<void*>* ptrs,\n    void* const replacement) {\n  MutexLock l(Mutex());\n  for (ThreadData* t = head_.next; t != &head_; t = t->next) {\n    if (id < t->entries.size()) {\n      void* ptr =\n          t->entries[id].ptr.exchange(replacement, std::memory_order_acquire);\n      if (ptr != nullptr) {\n        ptrs->push_back(ptr);\n      }\n    }\n  }\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br"),a("span",{staticClass:"line-number"},[e._v("21")]),a("br"),a("span",{staticClass:"line-number"},[e._v("22")]),a("br"),a("span",{staticClass:"line-number"},[e._v("23")]),a("br"),a("span",{staticClass:"line-number"},[e._v("24")]),a("br"),a("span",{staticClass:"line-number"},[e._v("25")]),a("br"),a("span",{staticClass:"line-number"},[e._v("26")]),a("br"),a("span",{staticClass:"line-number"},[e._v("27")]),a("br"),a("span",{staticClass:"line-number"},[e._v("28")]),a("br"),a("span",{staticClass:"line-number"},[e._v("29")]),a("br"),a("span",{staticClass:"line-number"},[e._v("30")]),a("br"),a("span",{staticClass:"line-number"},[e._v("31")]),a("br"),a("span",{staticClass:"line-number"},[e._v("32")]),a("br"),a("span",{staticClass:"line-number"},[e._v("33")]),a("br")])]),a("p",[e._v("这个时候，Writer 通过"),a("code",[e._v("Scrape")]),e._v(" 标记了当前 db 的所有的 tls 存储为过期，完成标记之前 可能有一个 reader 通过 "),a("code",[e._v("GetReferencedSuperVersion")]),e._v(" 创建了一个 tls 对象，创建完成之后被"),a("code",[e._v("Scrape")]),e._v(" 标记了过期，那这个时候 reader 需要通过 db 级别的锁来获取全局最新的"),a("code",[e._v("super_version_")]),e._v("，获取之后再更新本地的 local_sv。")]),e._v(" "),a("p",[e._v("需要注意的是获取全局 "),a("code",[e._v("super_version_")]),e._v(" 的时候需要保证获取期间不会有其他的 writer 更新这个 "),a("code",[e._v("super_version_")]),e._v("。")]),e._v(" "),a("p",[e._v("代码如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("SuperVersion* ColumnFamilyData::GetThreadLocalSuperVersion(\n    InstrumentedMutex* db_mutex) {\n  // The SuperVersion is cached in thread local storage to avoid acquiring\n  // mutex when SuperVersion does not change since the last use. When a new\n  // SuperVersion is installed, the compaction or flush thread cleans up\n  // cached SuperVersion in all existing thread local storage. To avoid\n  // acquiring mutex for this operation, we use atomic Swap() on the thread\n  // local pointer to guarantee exclusive access. If the thread local pointer\n  // is being used while a new SuperVersion is installed, the cached\n  // SuperVersion can become stale. In that case, the background thread would\n  // have swapped in kSVObsolete. We re-check the value at when returning\n  // SuperVersion back to thread local, with an atomic compare and swap.\n  // The superversion will need to be released if detected to be stale.\n  // 标记当前创建的 tls 是 kSVInUse，\n  void* ptr = local_sv_->Swap(SuperVersion::kSVInUse);\n  // Invariant:\n  // (1) Scrape (always) installs kSVObsolete in ThreadLocal storage\n  // (2) the Swap above (always) installs kSVInUse, ThreadLocal storage\n  // should only keep kSVInUse before ReturnThreadLocalSuperVersion call\n  // (if no Scrape happens).\n  assert(ptr != SuperVersion::kSVInUse);\n  SuperVersion* sv = static_cast<SuperVersion*>(ptr);\n  // 检测标记之后 可能因为writer 的 install 导致的Obsolete，则需要重新获取全局的sv\n  if (sv == SuperVersion::kSVObsolete ||\n      sv->version_number != super_version_number_.load()) {\n    RecordTick(ioptions_.statistics, NUMBER_SUPERVERSION_ACQUIRES);\n    SuperVersion* sv_to_delete = nullptr;\n\n    if (sv && sv->Unref()) {\n      RecordTick(ioptions_.statistics, NUMBER_SUPERVERSION_CLEANUPS);\n      db_mutex->Lock();\n      // NOTE: underlying resources held by superversion (sst files) might\n      // not be released until the next background job.\n      // 因为当前拿到的sv 已经过期了， 需要清理掉它占用的资源\n      sv->Cleanup();\n      sv_to_delete = sv;\n    } else {\n      db_mutex->Lock();\n    }\n    // 加锁获取全局的 super_version_\n    sv = super_version_->Ref();\n    db_mutex->Unlock();\n\n    delete sv_to_delete;\n  }// 当然，如果拿到的tls sv 并没有被标记为过期，则直接返回访问即可。\n  assert(sv != nullptr);\n  return sv;\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br"),a("span",{staticClass:"line-number"},[e._v("19")]),a("br"),a("span",{staticClass:"line-number"},[e._v("20")]),a("br"),a("span",{staticClass:"line-number"},[e._v("21")]),a("br"),a("span",{staticClass:"line-number"},[e._v("22")]),a("br"),a("span",{staticClass:"line-number"},[e._v("23")]),a("br"),a("span",{staticClass:"line-number"},[e._v("24")]),a("br"),a("span",{staticClass:"line-number"},[e._v("25")]),a("br"),a("span",{staticClass:"line-number"},[e._v("26")]),a("br"),a("span",{staticClass:"line-number"},[e._v("27")]),a("br"),a("span",{staticClass:"line-number"},[e._v("28")]),a("br"),a("span",{staticClass:"line-number"},[e._v("29")]),a("br"),a("span",{staticClass:"line-number"},[e._v("30")]),a("br"),a("span",{staticClass:"line-number"},[e._v("31")]),a("br"),a("span",{staticClass:"line-number"},[e._v("32")]),a("br"),a("span",{staticClass:"line-number"},[e._v("33")]),a("br"),a("span",{staticClass:"line-number"},[e._v("34")]),a("br"),a("span",{staticClass:"line-number"},[e._v("35")]),a("br"),a("span",{staticClass:"line-number"},[e._v("36")]),a("br"),a("span",{staticClass:"line-number"},[e._v("37")]),a("br"),a("span",{staticClass:"line-number"},[e._v("38")]),a("br"),a("span",{staticClass:"line-number"},[e._v("39")]),a("br"),a("span",{staticClass:"line-number"},[e._v("40")]),a("br"),a("span",{staticClass:"line-number"},[e._v("41")]),a("br"),a("span",{staticClass:"line-number"},[e._v("42")]),a("br"),a("span",{staticClass:"line-number"},[e._v("43")]),a("br"),a("span",{staticClass:"line-number"},[e._v("44")]),a("br"),a("span",{staticClass:"line-number"},[e._v("45")]),a("br"),a("span",{staticClass:"line-number"},[e._v("46")]),a("br"),a("span",{staticClass:"line-number"},[e._v("47")]),a("br"),a("span",{staticClass:"line-number"},[e._v("48")]),a("br")])]),a("p",[e._v("writer 更新 全局 super_version_ 并 标记所有的 tls sv 失效，reader 拿到 tls sv 做一些 检测 发现失效则通过 db 锁进行同步。")]),e._v(" "),a("p",[e._v("这个过程对 version 系统的访问能够极大得减少多线程下对 version 系统访问的同步开销，提升了 rocksdb 的读写性能。")]),e._v(" "),a("h2",{attrs:{id:"_2-写链路"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-写链路"}},[e._v("#")]),e._v(" 2. 写链路")]),e._v(" "),a("h3",{attrs:{id:"_2-1-joinbatchgroup"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-joinbatchgroup"}},[e._v("#")]),e._v(" 2.1 JoinBatchGroup")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://vigourtyy-zhg.blog.csdn.net/article/details/115562370",target:"_blank",rel:"noopener noreferrer"}},[e._v("从 JoinBatchGroup 代码细节 来看 Rocskdb 对写入逻辑的性能优化"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"_3-其他"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-其他"}},[e._v("#")]),e._v(" 3. 其他")]),e._v(" "),a("h3",{attrs:{id:"_3-1-用最低的代价获取-critical-path-的-statistics"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-用最低的代价获取-critical-path-的-statistics"}},[e._v("#")]),e._v(" 3.1 用最低的代价获取 critical path 的 Statistics")]),e._v(" "),a("p",[e._v("Rocksdb 拥有非常完善的运维体系，包括一百多个 tickers 和 几十个 histograms。这一些指标都是嵌入到整个 rocksdb workload 的 critical path 之中。比如"),a("code",[e._v("DB_GET")]),e._v(" 表示 Get 请求的延时，也就是每一次调用 Get 都会记录一次延时，并且后续通过"),a("code",[e._v("rocksdb.db.get.micros")]),e._v(" 取的时候计算直方图信息。")]),e._v(" "),a("p",[e._v("那如何保证在打开 statistics 之后 这么多关键路径的指标不会影响引擎本身的性能，且指标的存放和读取不会耗费过多的 cpu 呢?")]),e._v(" "),a("p",[e._v("引擎指标对于上层应用来说是必不可少的，那如何保证指标这里的性能就成为的关键了，接下来我们学习一下 Rocksdb 这里是怎么做的。")]),e._v(" "),a("ol",[a("li",[e._v("指标的收集")])]),e._v(" "),a("p",[e._v("以 histogram 类型的指标为例，"),a("code",[e._v("DB_GET")]),e._v("。在"),a("code",[e._v("GetImpl")]),e._v("入口处 通过"),a("code",[e._v("StopWatch sw(env_, stats_, DB_GET);")]),e._v("进行收集。 即 "),a("code",[e._v("StopWatch")]),e._v("类的构造函数是打一个时间点，析构函数会做一个时间差通过"),a("code",[e._v("reportTimeToHistogram")]),e._v("记录到 statistics 中。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("   ~StopWatch() {\n     if (elapsed_) {\n       if (overwrite_) {\n         *elapsed_ = env_->NowMicros() - start_time_;\n       } else {\n         *elapsed_ += env_->NowMicros() - start_time_;\n       }\n     }\n     if (elapsed_ && delay_enabled_) {\n       *elapsed_ -= total_delay_;\n     }\n     if (stats_enabled_) {\n       statistics_->reportTimeToHistogram(\n         hist_type_, (elapsed_ != nullptr)\n         ? *elapsed_\n         : (env_->NowMicros() - start_time_));\n     }\n   }\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br"),a("span",{staticClass:"line-number"},[e._v("17")]),a("br"),a("span",{staticClass:"line-number"},[e._v("18")]),a("br")])]),a("ol",[a("li",[e._v("指标的存储 存储 histogram 数据的调用栈如下：")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  reportTimeToHistogram\n     Statistics::recordInHistogram\n     \tStatisticsImpl::recordInHistogram\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("在"),a("code",[e._v("recordInHistogram")]),e._v("函数中，实现逻辑如下：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("   void StatisticsImpl<TICKER_MAX, HISTOGRAM_MAX>::recordInHistogram(\n       uint32_t histogramType, uint64_t value) {\n     assert(histogramType < HISTOGRAM_MAX);\n     if (get_stats_level() <= StatsLevel::kExceptHistogramOrTimers) {\n       return;\n     }\n     per_core_stats_.Access()->histograms_[histogramType].Add(value);\n     if (stats_ && histogramType < HISTOGRAM_MAX) {\n       stats_->recordInHistogram(histogramType, value);\n     }\n   }\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br")])]),a("p",[e._v("可以发现真正的存储是存放在了"),a("code",[e._v("per_core_stats_.Access()->histograms_[histogramType].Add(value)")]),e._v("，也就是一个"),a("code",[e._v("StatisticsData")]),e._v("类型的"),a("code",[e._v("CoreLocalArray")]),e._v("中。")]),e._v(" "),a("p",[a("code",[e._v("StatisticsData")]),e._v(" 的定义中重载了"),a("code",[e._v("new")]),e._v("和"),a("code",[e._v("delete")]),e._v(" 操作符，保证分配和释放都是"),a("code",[e._v("cacheline")]),e._v("对齐的。")]),e._v(" "),a("p",[e._v("为什么要有一个"),a("code",[e._v("CoreLocalArray")]),e._v("呢？")]),e._v(" "),a("p",[e._v("先来看看它的作用，通过"),a("code",[e._v("Access")]),e._v("函数 我们进入到了"),a("code",[e._v("AccessElementAndIndex")]),e._v("中")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("template <typename T>\nstd::pair<T*, size_t> CoreLocalArray<T>::AccessElementAndIndex() const {\n  // 获取当前的cpu-id\n  int cpuid = port::PhysicalCoreID();\n  size_t core_idx;\n  if (UNLIKELY(cpuid < 0)) {\n    // cpu id unavailable, just pick randomly\n    // 如果cpu id不可用，直接随便选择一个cpu id\n    core_idx = Random::GetTLSInstance()->Uniform(1 << size_shift_);\n  } else {\n    // 否则选择当前的cpu id\n    core_idx = static_cast<size_t>(cpuid & ((1 << size_shift_) - 1));\n  }\n  // 取当前cpu-id 缓存的 StatisticsData 类型的地址返回。\n  return {AccessAtCore(core_idx), core_idx};\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br"),a("span",{staticClass:"line-number"},[e._v("13")]),a("br"),a("span",{staticClass:"line-number"},[e._v("14")]),a("br"),a("span",{staticClass:"line-number"},[e._v("15")]),a("br"),a("span",{staticClass:"line-number"},[e._v("16")]),a("br")])]),a("p",[e._v("最后使用当前 cpu id 的 对象地址 "),a("code",[e._v("Add")]),e._v(" 记录下来的指标数据。")]),e._v(" "),a("p",[e._v("大体上能够发现，我们的指标数据是缓存在执行当前"),a("code",[e._v("Get")]),e._v("操作的 cpu 上。")]),e._v(" "),a("p",[e._v("后续拿该指标的时候通过"),a("code",[e._v("getHistogramImplLocked")])]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("std::unique_ptr<HistogramImpl>\nStatisticsImpl<TICKER_MAX, HISTOGRAM_MAX>::getHistogramImplLocked(\n    uint32_t histogramType) const {\n  assert(histogramType < HISTOGRAM_MAX);\n  std::unique_ptr<HistogramImpl> res_hist(new HistogramImpl());\n  // 访问当前cpu的所有core，取每一个core 之前存储的该指标的数据。\n  for (size_t core_idx = 0; core_idx < per_core_stats_.Size(); ++core_idx) {\n    res_hist->Merge(\n        per_core_stats_.AccessAtCore(core_idx)->histograms_[histogramType]);\n  }\n  return res_hist;\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br"),a("span",{staticClass:"line-number"},[e._v("9")]),a("br"),a("span",{staticClass:"line-number"},[e._v("10")]),a("br"),a("span",{staticClass:"line-number"},[e._v("11")]),a("br"),a("span",{staticClass:"line-number"},[e._v("12")]),a("br")])]),a("p",[e._v("我们大概知道了"),a("code",[e._v("CoreLocalArray")]),e._v("在指标集中的用法， 那 rocksdb 为什么要用这样的方式保存指标呢？")]),e._v(" "),a("p",[e._v("在关键路径上的额外处理逻辑每一步都可能影响性能，我们将指标随便保存在内存中，后续的用户线程 以及 引擎内部的 stats 打印线程 读取则可能涉及跨 numa 访问，同样会造成额外的 cpu 开销。")]),e._v(" "),a("p",[e._v("如果我们将指标按照 core-id 保存在各自 core 的本地存储中（cpu-cache / 距离 cpu 近的内存中），而且保证了"),a("code",[e._v("StatisticsData")]),e._v("的分配和释放都是 cache-line 对齐，那么在访问过程中从本地 core 存储按照 cache-line 读取能够极大得减少跨 numa 以及 cache-line 补齐 的开销，最大程度得保证了指标访问的性能 ，减少对系统 CPU 资源的占用。")]),e._v(" "),a("p",[e._v("全文完")]),e._v(" "),a("p",[e._v("本文由 "),a("a",{attrs:{href:"http://ksria.com/simpread",target:"_blank",rel:"noopener noreferrer"}},[e._v("简悦 SimpRead"),a("OutboundLink")],1),e._v(" 优化，用以提升阅读体验")]),e._v(" "),a("p",[e._v("使用了 全新的简悦词法分析引擎 beta，"),a("a",{attrs:{href:"http://ksria.com/simpread/docs/#/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%BC%95%E6%93%8E",target:"_blank",rel:"noopener noreferrer"}},[e._v("点击查看"),a("OutboundLink")],1),e._v("详细说明")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/417266348#sr-toc-0",target:"_blank",rel:"noopener noreferrer"}},[e._v("1. 读链路"),a("OutboundLink")],1),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/417266348#sr-toc-1",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.1 FileIndexer"),a("OutboundLink")],1),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/417266348#sr-toc-2",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.1.1 LevelDB sst 查找实现"),a("OutboundLink")],1),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/417266348#sr-toc-3",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.1.2 Rocksdb FileIndexer 实现"),a("OutboundLink")],1),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/417266348#sr-toc-4",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.2 PinnableSlice 减少内存拷贝"),a("OutboundLink")],1),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/417266348#sr-toc-5",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.3 Cache"),a("OutboundLink")],1),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/417266348#sr-toc-6",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.3.1 LRU Cache"),a("OutboundLink")],1),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/417266348#sr-toc-7",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.3.2 Clock Cache"),a("OutboundLink")],1),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/417266348#sr-toc-8",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.4 ThreadLocalPtr 线程私有存储"),a("OutboundLink")],1),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/417266348#sr-toc-9",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.4.1 version 系统"),a("OutboundLink")],1),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/417266348#sr-toc-10",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.4.2 C++ thread_local vs ThreadLocalPtr"),a("OutboundLink")],1),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/417266348#sr-toc-11",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.4.3 ThreadLocalPtr 设计"),a("OutboundLink")],1),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/417266348#sr-toc-12",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.4.4 ThreadLocalPtr 在 version 系统中的应用"),a("OutboundLink")],1),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/417266348#sr-toc-13",target:"_blank",rel:"noopener noreferrer"}},[e._v("2. 写链路"),a("OutboundLink")],1),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/417266348#sr-toc-14",target:"_blank",rel:"noopener noreferrer"}},[e._v("2.1 JoinBatchGroup"),a("OutboundLink")],1),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/417266348#sr-toc-15",target:"_blank",rel:"noopener noreferrer"}},[e._v("3. 其他"),a("OutboundLink")],1),a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/417266348#sr-toc-16",target:"_blank",rel:"noopener noreferrer"}},[e._v("3.1 用最低的代价获取 critical path 的 Statistics"),a("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=t.exports}}]);