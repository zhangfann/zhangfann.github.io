(window.webpackJsonp=window.webpackJsonp||[]).push([[186],{569:function(n,e,t){"use strict";t.r(e);var _=t(42),a=Object(_.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"源码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#源码"}},[n._v("#")]),n._v(" 源码")]),n._v(" "),t("h2",{attrs:{id:"libevent网络模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#libevent网络模型"}},[n._v("#")]),n._v(" libevent网络模型")]),n._v(" "),t("p",[n._v("主要是主线程把连接分派给工作线程")]),n._v(" "),t("p",[n._v("memcached.c\nmain\n处理命令行参数\n_单个字符，表示选项，\n_单个字符后接一个冒号：表示该选项后必须跟一个参数。参数紧跟在选项后或者以空格隔开。该参数的指针赋给optarg。\n_单个字符后跟两个冒号，表示该选项后必须跟一个参数。参数必须"),t("strong",[n._v("紧跟在选项后")]),n._v("不能以空格隔开。该参数的指针赋给optarg。（这个特性是GNU的扩张）\n内部容器数据结构初始化 @assoc_init @assoc.c\n内部容器就是memcached中用于存储数据的结构\n空闲连接数组初始化 @conn_init\n这个是管理和用户的连接")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("    主线程server启动 @server_sockets\n\n    非常重要, 创建4个工作线程 >> @thread_init @thread.c\n    进入主线程事件循环 @event_base_loop\n\nconn_new\n    $thread_libevent_process调用\n        主线程建立连接是监听socket的建立\n        工作线程是监听socket读写\n        @event_set(event_handler)\n    $server_sockets\n        为主线程监听连接事件 \n        >> drive_machine.conn_listening\nevent_handler\n    @drive_machine memcached大多数网络事件都交给了drive_machine\ndrive_machine\n    c->state\n        $主线程\n            _conn_listening 正在连接 还没有accept\n                只有主线程会进入\n                accept 接受连接\n                将socket交给工作线程处理 @dispatch_conn_new\n                    向工作线程队列放入任务\n                    >> conn_new_cmd\n\n        $工作线程\n            _初始阶段\n                _conn_new_cmd\n                    _已经读入一些数据(c->rbytes > 0) >> conn_parse_cmd\n                    _未读入数据 >> conn_waiting\n                _conn_waiting 等待新的命令请求\n                    >> conn_read\n            _读取到数据\n                _conn_read 读取数据\n                    _未读入数据 >> conn_waiting\n                    _读取数据成功 >> conn_parse_cmd\n                    _读取错误 >> conn_closing\n            \n            _conn_parse_cmd 解析命令\n                \\try_read_cmd 尝试解析命令\n                    _二进制协议 @dispatch_bin_command\n                    _字符协议 @process_command\n                _解析完成\n                    ??不太清楚转换\n                _为解析完成\n                    >> conn_waiting 等待读入更多数据\n            _conn_nread ??猜测是根据读入的n个字符执行后调用\n")])])]),t("p",[n._v("thread.c\nthread_init 创建工作线程\n创建每个线程的libevent的event_base @setup_thread\n创建worker线程 @create_worker\n>> worker线程 @worker_libevent\nsetup_thread 创建线程的event_base\n每个libevent的线程都应该有一个自己独立的event_base @event_init\n对于读事件的监听 @event_set(@thread_libevent_process 使用thread_libevent_process进行回调)\n添加事件操作\n初始化工作队列")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("worker_libevent worker线程入口\n    进入事件循环 @event_base_loop\nthread_libevent_process 有读数据时回调\n    从cq工作线程队列中取出一个item \n    并建立连接 >> @conn_new(thread_libevent_process调用)\n")])])]),t("p",[n._v("assoc.c\n关联容器 是存储memcached核心数据的")]),n._v(" "),t("p",[n._v("cache.c\n??")]),n._v(" "),t("p",[n._v("hash.c")]),n._v(" "),t("p",[n._v("item.c")]),n._v(" "),t("p",[n._v("slabs.c")]),n._v(" "),t("h1",{attrs:{id:"安装"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装"}},[n._v("#")]),n._v(" 安装")]),n._v(" "),t("p",[n._v("wget http://memcached.org/latest\ntar -zxvf latest\ncd memcached-1.6.14/\nsudo apt install libevent-2.1-7 libevent-dev\n./configure --prefix=/usr/local/memcached\nmake -j\nsudo make install")])])}),[],!1,null,null,null);e.default=a.exports}}]);