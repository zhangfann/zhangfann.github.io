(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{126:function(a,t,e){"use strict";e.r(t);var r=e(0),_=Object(r.a)({},function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简介","aria-hidden":"true"}},[a._v("#")]),a._v(" 简介")]),a._v(" "),e("h2",{attrs:{id:"架构设计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#架构设计","aria-hidden":"true"}},[a._v("#")]),a._v(" 架构设计")]),a._v(" "),e("p",[e("img",{attrs:{src:"/mysql/arch.bmp",alt:"pic"}})]),a._v(" "),e("h2",{attrs:{id:"系统设计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#系统设计","aria-hidden":"true"}},[a._v("#")]),a._v(" 系统设计")]),a._v(" "),e("h3",{attrs:{id:"主线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主线程","aria-hidden":"true"}},[a._v("#")]),a._v(" 主线程")]),a._v(" "),e("h4",{attrs:{id:"主循环"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主循环","aria-hidden":"true"}},[a._v("#")]),a._v(" 主循环")]),a._v(" "),e("p",[a._v("主循环分为每1s操作, 和每10s操作")]),a._v(" "),e("p",[a._v("每1s操作,\n重做日志刷新到磁盘,\n如果io压力小,\n合并插入缓冲,\n如果脏页超过阈值,\n刷新100脏页到磁盘,\n如果用户无活动,\n进入后台循环")]),a._v(" "),e("p",[a._v("每10s操作,\n重做日志刷新到磁盘,\n合并插入缓冲,\n删除无用undo页,\n刷新100脏页到磁盘,\n产生一个检查点,")]),a._v(" "),e("h4",{attrs:{id:"后台循环"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#后台循环","aria-hidden":"true"}},[a._v("#")]),a._v(" 后台循环")]),a._v(" "),e("p",[a._v("后台循环, 数据库空闲时调用,\n合并插入缓冲,\n删除无用undo页,\n如果非空闲,\n进入主循环,\n否则进入刷新循环")]),a._v(" "),e("h4",{attrs:{id:"刷新循环"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#刷新循环","aria-hidden":"true"}},[a._v("#")]),a._v(" 刷新循环")]),a._v(" "),e("p",[a._v("刷新100脏页到磁盘,\n如果脏页仍超过阈值,\n继续刷新循环")]),a._v(" "),e("h3",{attrs:{id:"b-索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#b-索引","aria-hidden":"true"}},[a._v("#")]),a._v(" B+索引")]),a._v(" "),e("h4",{attrs:{id:"插入"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#插入","aria-hidden":"true"}},[a._v("#")]),a._v(" 插入")]),a._v(" "),e("p",[a._v("B+树插入分为3种情况")]),a._v(" "),e("ul",[e("li",[a._v("leaf page未满, 索引页未满, 直接将记录插入leaf page")]),a._v(" "),e("li",[a._v("leaf page满, index page未满,\n"),e("ul",[e("li",[a._v("拆分leaf page")]),a._v(" "),e("li",[a._v("将中间的记录放入index page")]),a._v(" "),e("li",[a._v("小于中间节点的记录放入左边")]),a._v(" "),e("li",[a._v("大于等于中间节点的记录放入右边")])])]),a._v(" "),e("li",[a._v("leaf page满, index page满\n"),e("ul",[e("li",[a._v("拆分leaf page")]),a._v(" "),e("li",[a._v("小于中间节点的放左边")]),a._v(" "),e("li",[a._v("大于等于中间节点的记录放右边")]),a._v(" "),e("li",[a._v("拆分index page")]),a._v(" "),e("li",[a._v("小于中间节点的记录放左边")]),a._v(" "),e("li",[a._v("大于中间节点的记录放右边")]),a._v(" "),e("li",[a._v("中间节点放入上层index page")])])])]),a._v(" "),e("p",[a._v("例子")]),a._v(" "),e("p",[a._v("初始状态\n"),e("img",{attrs:{src:"/mysql/b_insert_1.bmp",alt:"初始状态"}})]),a._v(" "),e("p",[a._v("插入28, 叶节点没满, 直接插入\n"),e("img",{attrs:{src:"/mysql/b_insert_2.bmp",alt:"插入28"}})]),a._v(" "),e("p",[a._v("插入70, 索引节点没满, 插到第三个节点, 并将第三个节点拆分\n"),e("img",{attrs:{src:"/mysql/b_insert_3.bmp",alt:"插入70"}})]),a._v(" "),e("p",[a._v("插入95, 到最右节点, 最右节点拆分, 中位数到索引节点, 索引节点再拆分\n"),e("img",{attrs:{src:"/mysql/b_insert_4.bmp",alt:"插入95"}})]),a._v(" "),e("p",[a._v("兄弟节点合并\n"),e("img",{attrs:{src:"/mysql/b_insert_5.bmp",alt:"合并"}})]),a._v(" "),e("h4",{attrs:{id:"删除"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#删除","aria-hidden":"true"}},[a._v("#")]),a._v(" 删除")]),a._v(" "),e("p",[a._v("删除分为3种情况")]),a._v(" "),e("ul",[e("li",[a._v("leaf page在阈值上, index page在阈值上,\n直接将记录从叶节点删除, 如果该节点在index page中,\n用该节点的右节点替代")]),a._v(" "),e("li",[a._v("leaf page在阈值下, index page在阈值下,\n合并叶节点及其兄弟节点, 更新index节点")]),a._v(" "),e("li",[a._v("leaf page在阈值下, index page在阈值下\n"),e("ul",[e("li",[a._v("合并叶节点及其兄弟节点")]),a._v(" "),e("li",[a._v("更新index page")]),a._v(" "),e("li",[a._v("合并index page及其兄弟节点")])])])]),a._v(" "),e("p",[a._v("例子")]),a._v(" "),e("p",[a._v("初始状态\n"),e("img",{attrs:{src:"/mysql/b_insert_4.bmp",alt:"插入95"}})]),a._v(" "),e("p",[a._v("删除70, 直接删除\n"),e("img",{attrs:{src:"/mysql/b_delete_2.bmp",alt:"删除70"}})]),a._v(" "),e("p",[a._v("删除25, 删除后索引节点中更新一下\n"),e("img",{attrs:{src:"/mysql/b_delete_3.bmp",alt:"删除25"}})]),a._v(" "),e("p",[a._v("删除60, 叶节点和索引节点分别进行合并\n"),e("img",{attrs:{src:"/mysql/b_delete_4.bmp",alt:"删除25"}})]),a._v(" "),e("h4",{attrs:{id:"聚集索引-辅助索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#聚集索引-辅助索引","aria-hidden":"true"}},[a._v("#")]),a._v(" 聚集索引, 辅助索引")]),a._v(" "),e("p",[a._v("聚集索引以主键为索引, 存全部数据,\n辅助索引, 以其他键为索引, 只存部分数据, 并给出主键,\n完整数据还需要根据主键查找聚集索引,")]),a._v(" "),e("p",[a._v("如果取大量数据, mysql也许不会使用索引,\n或者有些列上没有建立索引,\n此时, 就需要通过遍历的方式")]),a._v(" "),e("h4",{attrs:{id:"联合索引"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#联合索引","aria-hidden":"true"}},[a._v("#")]),a._v(" 联合索引")]),a._v(" "),e("p",[a._v("两个以上列组成的索引,\n排列时, 先比较第1位, 然后第2位 …")]),a._v(" "),e("h4",{attrs:{id:"自适应哈希"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自适应哈希","aria-hidden":"true"}},[a._v("#")]),a._v(" 自适应哈希")]),a._v(" "),e("p",[a._v("键值(主键或其他键)直接对于数据行,\n自适应哈希主要是查找select * from xxtable where key=xxkey,\n擅长精准查找, 但是不能范围查找")]),a._v(" "),e("h3",{attrs:{id:"表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#表","aria-hidden":"true"}},[a._v("#")]),a._v(" 表")]),a._v(" "),e("h4",{attrs:{id:"段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#段","aria-hidden":"true"}},[a._v("#")]),a._v(" 段")]),a._v(" "),e("p",[a._v("段分为数据段, 索引段,\ninnodb存储引擎是索引组织的,\n数据即索引, 索引即数据,\n数据是b+树的叶节点, 索引是b+树的非叶节点")]),a._v(" "),e("h4",{attrs:{id:"页"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#页","aria-hidden":"true"}},[a._v("#")]),a._v(" 页")]),a._v(" "),e("p",[a._v("mysql中先通过b+树找到记录所在的页,\n然后在页中再利用page directory中通过二叉查找, 找到具体记录,")]),a._v(" "),e("h4",{attrs:{id:"约束"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#约束","aria-hidden":"true"}},[a._v("#")]),a._v(" 约束")]),a._v(" "),e("p",[a._v("完整性\n实体完整性, 保证唯一主键\n域完整性, 保证值都是特定类型\n参照完整性, 保证两张表间的外键关系,")]),a._v(" "),e("h4",{attrs:{id:"触发器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#触发器","aria-hidden":"true"}},[a._v("#")]),a._v(" 触发器")]),a._v(" "),e("p",[a._v("在insert/delete/update的before或after调用,\n对数据进行检查,")]),a._v(" "),e("h3",{attrs:{id:"并发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#并发","aria-hidden":"true"}},[a._v("#")]),a._v(" 并发")]),a._v(" "),e("h4",{attrs:{id:"锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#锁","aria-hidden":"true"}},[a._v("#")]),a._v(" 锁")]),a._v(" "),e("p",[a._v("mysql读取数据时, 对该数据记录一个版本号,\n之后事务中, 每次都读取该版本号数据,\n更新时, mysql会读取事务版本号和当前mysql中最新版本号,\n相同, 则进行更新, 否则回滚失败,")]),a._v(" "),e("h4",{attrs:{id:"死锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#死锁","aria-hidden":"true"}},[a._v("#")]),a._v(" 死锁")]),a._v(" "),e("p",[a._v("一个例子\nt1: select a=1 for update, t1把1锁住,\nt2: select a=2 for update, t2把2锁住,\nt1: select a=2 for update, t1等待t2,\nt2: select a=1 for update, t2等待t1")]),a._v(" "),e("h4",{attrs:{id:"隔离级别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#隔离级别","aria-hidden":"true"}},[a._v("#")]),a._v(" 隔离级别")]),a._v(" "),e("p",[a._v("读未提交： 可以及时读到及时数据,\nRead Uncommitted，顾名思义，就是一个事务可以读取另一个未提交事务的数据。最低级别，它存在 4 个常见问题（脏读、不可重复读、幻读、丢失更新）。")]),a._v(" "),e("p",[a._v("读已提交： 读最新版历史数据,\nRead Committed，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。 它解决了脏读问题，存在 3 个常见问题（不可重复读、幻读、丢失更新）。")]),a._v(" "),e("p",[a._v("可重复读： 读固定版历史数据,\nRepeatable Read，就是在开始读取数据（事务开启）时，不再允许修改操作 。它解决了脏读和不可重复读，还存在 2 个常见问题（幻读、丢失更新）。")]),a._v(" "),e("p",[a._v("丢失更新,\nmysql一般是可重复读的, 对于丢失更新, 它的解决方式是\n读取历史版本数据时, 同时记录版本号,\n在更新时, 如果版本号相同, 进行更新,\n版本号不同, 更新失败,")]),a._v(" "),e("p",[a._v("幻读,\n事务select一个数据, 发现数据不存在, 插入时, 发现数据已存在,\n大部分幻读是可以接受的,\n要想避免可以使用select … for update,")]),a._v(" "),e("p",[a._v("序列化： 完全顺序读\nSerializable，序列化，或串行化。就是将每个事务按一定的顺序去执行，它将隔离问题全部解决，但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。")]),a._v(" "),e("h3",{attrs:{id:"事务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事务","aria-hidden":"true"}},[a._v("#")]),a._v(" 事务")]),a._v(" "),e("p",[a._v("acid")]),a._v(" "),e("p",[a._v("原子性, 要么全做, 要么全不做,")]),a._v(" "),e("p",[a._v("一致性, 保证主键, 外键, 数据类型等约束符合定义,")]),a._v(" "),e("p",[a._v("隔离性, 客户端任何时刻都可以认为只有自己在操作,")]),a._v(" "),e("p",[a._v("持久性, 只要事务返回成功, 那么它一定成功更新了数据库, 无论数据库之后是否挂了")]),a._v(" "),e("h4",{attrs:{id:"重做日志"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重做日志","aria-hidden":"true"}},[a._v("#")]),a._v(" 重做日志")]),a._v(" "),e("p",[a._v("redo log和undo log在功能上经常一起使用,\n在理论上, 也都是事务日志的概念,\n所以可以将二者视为同一日志,\n不过redo log记录新值, 实现持久性,\nundo log记录旧值, 实现原子性,")]),a._v(" "),e("p",[a._v("redo log记录在磁盘的文件中,\nib_logfile0, ib_logfile1,\n记录了事务, 对于数据恢复非常重要,\n重做日志从缓存刷向磁盘时, 在ib_logfile0和ib_logfile1之间循环写入")]),a._v(" "),e("p",[a._v("与二进制日志区别,\n二进制日志记录所有与mysql相关的内容, 以及具体操作,\n而且在提交事务前记录,\n重做日志, 记录每个页改变的物理情况\n在事务进行过程中, 不断提交")]),a._v(" "),e("h4",{attrs:{id:"undo页"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#undo页","aria-hidden":"true"}},[a._v("#")]),a._v(" undo页")]),a._v(" "),e("p",[a._v("undo页记录了历史数据,\n一个作用是事务读取数据时, 提供历史版本数据,\n另个作用是死锁时, 进行回滚,")]),a._v(" "),e("p",[a._v("undo记录的是逻辑信息,\n比如对于每个insert记录一个delete,\n对于每个update, 记录一个复原的update")]),a._v(" "),e("p",[a._v("在事务commit后, 会被标记为无用的undo页,")]),a._v(" "),e("h4",{attrs:{id:"wal"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#wal","aria-hidden":"true"}},[a._v("#")]),a._v(" WAL")]),a._v(" "),e("p",[a._v("在对数据修改前, 记录undo log, 修改后, 记录redo log,\n事务提交前, 只向磁盘写redo log\nundo log和数据都不向磁盘写, 这样可以减少io\n当脏页刷入磁盘, redo log就没有用了,")]),a._v(" "),e("p",[a._v("redo log只能追加, 并且为了io性能, 会多个事务写入同一日志,\n因此会造成未提交事务也写入redo 日志,\n在恢复时, 会重做所有redo log,\n其中未记录commit的事务,\n会通过undo log回滚,\n理论上commit后, undo就没用了,\n但由于mvcc, 其他事务可能还依赖undo信息,\n所以需要等到undo信息没有引用后, 再释放,")]),a._v(" "),e("p",[a._v("mysql的checkpoint记录了mysql的LSN(日志序号号),\n恢复时从这个LSN开始即可,")]),a._v(" "),e("h3",{attrs:{id:"复制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#复制","aria-hidden":"true"}},[a._v("#")]),a._v(" 复制")]),a._v(" "),e("p",[a._v("备机io线程从主机的二进制日志读取到relay log,\nsql线程按照relay log写入数据库,")]),a._v(" "),e("h3",{attrs:{id:"日志"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#日志","aria-hidden":"true"}},[a._v("#")]),a._v(" 日志")]),a._v(" "),e("h4",{attrs:{id:"二进制日志"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二进制日志","aria-hidden":"true"}},[a._v("#")]),a._v(" 二进制日志")]),a._v(" "),e("p",[a._v("binlog在事务提交前, 一次性写入磁盘,\n不像redo分次提交, 因此binlog会对io造成一定压力\n理论上是先提交redo日志, 再提交binlog日志, 才算commit完成,")])])},[],!1,null,null,null);t.default=_.exports}}]);