(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{129:function(a,t,r){"use strict";r.r(t);var e=r(0),n=Object(e.a)({},function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简介","aria-hidden":"true"}},[a._v("#")]),a._v(" 简介")]),a._v(" "),r("h2",{attrs:{id:"架构设计"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#架构设计","aria-hidden":"true"}},[a._v("#")]),a._v(" 架构设计")]),a._v(" "),r("p",[r("img",{attrs:{src:"/mysql/mysql_arch.png",alt:"pic"}})]),a._v(" "),r("h2",{attrs:{id:"系统设计"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#系统设计","aria-hidden":"true"}},[a._v("#")]),a._v(" 系统设计")]),a._v(" "),r("h3",{attrs:{id:"主线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主线程","aria-hidden":"true"}},[a._v("#")]),a._v(" 主线程")]),a._v(" "),r("p",[a._v("主线程")]),a._v(" "),r("p",[a._v("主循环")]),a._v(" "),r("p",[a._v("后台循环")]),a._v(" "),r("p",[a._v("刷新循环")]),a._v(" "),r("p",[a._v("暂停循环")]),a._v(" "),r("h4",{attrs:{id:"主循环"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主循环","aria-hidden":"true"}},[a._v("#")]),a._v(" 主循环")]),a._v(" "),r("p",[a._v("每1s操作,\n重做日志刷新到磁盘,\n如果io压力小,\n合并插入缓冲,\n如果脏页超过阈值,\n刷新100脏页到磁盘,\n刷新脏页(),\n如果用户无活动,\n后台循环")]),a._v(" "),r("p",[a._v("每10s操作,\n重做日志刷新到磁盘,\n合并插入缓冲,\n删除无用undo页,\n刷新100脏页到磁盘,\n// 与二次写有关,\n刷新脏页(),\n产生一个检查点,")]),a._v(" "),r("p",[a._v("后台循环, 数据库空闲时调用,\n后台循环的操作都是内存态的,\n合并插入缓冲,\n删除无用undo页,\n如果非空闲,\n主循环,\n否则刷新循环")]),a._v(" "),r("p",[a._v("刷新循环\n刷新循环主要是与磁盘交互,\n刷新100脏页到磁盘,\n刷新脏页(),\n如果脏页超过阈值,\n刷新循环")]),a._v(" "),r("p",[a._v("暂停循环")]),a._v(" "),r("h3",{attrs:{id:"索引"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#索引","aria-hidden":"true"}},[a._v("#")]),a._v(" 索引")]),a._v(" "),r("p",[r("img",{attrs:{src:"/mysql/b1.png",alt:"pic"}}),a._v(" "),r("img",{attrs:{src:"/mysql/b2.png",alt:"pic"}}),a._v(" "),r("img",{attrs:{src:"/mysql/b3.png",alt:"pic"}}),a._v(" "),r("img",{attrs:{src:"/mysql/b4.png",alt:"pic"}}),a._v(" "),r("img",{attrs:{src:"/mysql/b5.png",alt:"pic"}}),a._v(" "),r("img",{attrs:{src:"/mysql/b6.png",alt:"pic"}})]),a._v(" "),r("h3",{attrs:{id:"聚集索引-辅助索引"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#聚集索引-辅助索引","aria-hidden":"true"}},[a._v("#")]),a._v(" 聚集索引, 辅助索引")]),a._v(" "),r("p",[a._v("聚集索引以主键为索引, 存全部数据,\n辅助索引, 以其他键为索引, 只存部分数据, 并给出主键,\n完整数据还需要根据主键查找聚集索引,")]),a._v(" "),r("p",[a._v("如果取大量数据, mysql也许不会使用索引,\n或者有些列上没有建立索引,\n此时, 就需要通过遍历的方式")]),a._v(" "),r("h3",{attrs:{id:"联合索引"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#联合索引","aria-hidden":"true"}},[a._v("#")]),a._v(" 联合索引")]),a._v(" "),r("p",[a._v("两个以上列组成的索引,\n排列时, 先比较第1位, 然后第2位 …")]),a._v(" "),r("h3",{attrs:{id:"自适应哈希"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#自适应哈希","aria-hidden":"true"}},[a._v("#")]),a._v(" 自适应哈希")]),a._v(" "),r("p",[a._v("键值(主键或其他键)直接对于数据行,\n自适应哈希主要是查找select * from xxtable where key=xxkey,\n擅长精准查找, 但是不能范围查找")]),a._v(" "),r("h3",{attrs:{id:"表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#表","aria-hidden":"true"}},[a._v("#")]),a._v(" 表")]),a._v(" "),r("h4",{attrs:{id:"段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#段","aria-hidden":"true"}},[a._v("#")]),a._v(" 段")]),a._v(" "),r("p",[a._v("todo,\n段分为数据段, 索引段,\ninnodb存储引擎是索引组织的,\n数据即索引, 索引即数据,\n数据是b+树的叶节点, 索引是b+树的非叶节点")]),a._v(" "),r("h4",{attrs:{id:"页"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#页","aria-hidden":"true"}},[a._v("#")]),a._v(" 页")]),a._v(" "),r("p",[a._v("mysql中先通过b+树找到记录所在的页,\n然后在页中再利用page directory中通过二叉查找, 找到具体记录,")]),a._v(" "),r("h4",{attrs:{id:"约束"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#约束","aria-hidden":"true"}},[a._v("#")]),a._v(" 约束")]),a._v(" "),r("p",[a._v("完整性\n实体完整性, 保证唯一主键\n域完整性, 保证值都是特定类型\n参照完整性, 保证两张表间的外键关系,")]),a._v(" "),r("h4",{attrs:{id:"触发器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#触发器","aria-hidden":"true"}},[a._v("#")]),a._v(" 触发器")]),a._v(" "),r("p",[a._v("在insert/delete/update的before或after调用,\n对数据进行检查,")]),a._v(" "),r("h3",{attrs:{id:"锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#锁","aria-hidden":"true"}},[a._v("#")]),a._v(" 锁")]),a._v(" "),r("p",[a._v("mysql读取数据时, 对该数据记录一个版本号,\n之后事务中, 每次都读取该版本号数据,\n更新时, mysql会读取事务版本号和当前mysql中最新版本号,\n相同, 则进行更新, 否则回滚失败,")]),a._v(" "),r("h4",{attrs:{id:"死锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#死锁","aria-hidden":"true"}},[a._v("#")]),a._v(" 死锁")]),a._v(" "),r("p",[a._v("一个例子\nt1: select a=1 for update, t1把1锁住,\nt2: select a=2 for update, t2把2锁住,\nt1: select a=2 for update, t1等待t2,\nt2: select a=1 for update, t2等待t1")]),a._v(" "),r("h4",{attrs:{id:"隔离级别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#隔离级别","aria-hidden":"true"}},[a._v("#")]),a._v(" 隔离级别")]),a._v(" "),r("p",[a._v("读未提交： 可以及时读到及时数据\nRead Uncommitted，顾名思义，就是一个事务可以读取另一个未提交事务的数据。最低级别，它存在 4 个常见问题（脏读、不可重复读、幻读、丢失更新）。")]),a._v(" "),r("p",[a._v("读已提交： 读最新版历史数据\nRead Committed，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。 它解决了脏读问题，存在 3 个常见问题（不可重复读、幻读、丢失更新）。")]),a._v(" "),r("p",[a._v("可重复读： 读固定版历史数据\nRepeatable Read，就是在开始读取数据（事务开启）时，不再允许修改操作 。它解决了脏读和不可重复读，还存在 2 个常见问题（幻读、丢失更新）。\n丢失更新\nmysql一般是可重复读的, 对于丢失更新, 它的解决方式是\n读取历史版本数据时, 同时记录版本号,\n在更新时, 如果版本号相同, 进行更新,\n版本号不同, 更新失败,\n幻读\n事务select一个数据, 发现数据不存在, 插入时, 发现数据已存在,\n大部分幻读是可以接受的,\n要想避免可以使用select … for update,")]),a._v(" "),r("p",[a._v("序列化： 完全顺序读\nSerializable，序列化，或串行化。就是将每个事务按一定的顺序去执行，它将隔离问题全部解决，但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。")]),a._v(" "),r("h3",{attrs:{id:"事务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#事务","aria-hidden":"true"}},[a._v("#")]),a._v(" 事务")]),a._v(" "),r("p",[a._v("事务关注的是如何保证内存和磁盘的一致性\nacid\n原子性, 要么全做, 要么全不做\n一致性, todo\n隔离性, 客户端任何时刻都可以认为只有自己在操作\n持久性, 只要事务返回成功, 那么它一定成功更新了数据库, 无论数据库之后是否挂了")]),a._v(" "),r("h4",{attrs:{id:"重做日志"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#重做日志","aria-hidden":"true"}},[a._v("#")]),a._v(" 重做日志")]),a._v(" "),r("p",[a._v("redo log和undo log在功能上经常一起使用,\n在理论上, 也都是事务日志的概念,\n所以可以将二者视为同一日志,\n不过redo log记录新值, 实现持久性,\nundo log记录旧值, 实现原子性,")]),a._v(" "),r("p",[a._v("ib_logfile0, ib_logfile1\n记录了事务, 对于数据恢复非常重要\n与二进制日志区别\n二进制日志记录所有与mysql相关的内容, 以及具体操作,\n而且在提交事务前记录\n重做日志, 记录每个页改变的物理情况\n在事务进行过程中, 不断提交")]),a._v(" "),r("p",[a._v("重做日志从缓存刷向磁盘时, 在ib_logfile0和ib_logfile1之间循环写入")]),a._v(" "),r("h4",{attrs:{id:"undo页"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#undo页","aria-hidden":"true"}},[a._v("#")]),a._v(" undo页")]),a._v(" "),r("p",[a._v("undo页记录了历史数据,\n一个作用是事务读取数据时, 提供历史版本数据\n另个作用是死锁时, 进行回滚")]),a._v(" "),r("p",[a._v("undo记录的是逻辑信息,\n比如对于每个insert记录一个delete,\n对于每个update, 记录一个复原的update")]),a._v(" "),r("p",[a._v("在事务commit后, 会被标记为无用的undo页,")]),a._v(" "),r("h4",{attrs:{id:"wal"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#wal","aria-hidden":"true"}},[a._v("#")]),a._v(" WAL")]),a._v(" "),r("p",[a._v("在对数据修改前, 记录undo log, 修改后, 记录redo log,\n事务提交前, 只向磁盘写redo log\nundo log和数据都不向磁盘写, 这样可以减少io\n当脏页刷入磁盘, redo log就没有用了,")]),a._v(" "),r("p",[a._v("done, commit之后, undo不就没有意义了吗?\nredo log只能追加, 并且为了io性能, 会多个事务写入同一日志,\n因此会造成未提交事务也写入redo 日志,\n在恢复时, 会重做所有redo log,\n其中未记录commit的事务,\n会通过undo log回滚,\n理论上commit后, undo就没用了,\n但由于mvcc, 其他事务可能还依赖undo信息,\n所以需要等到undo信息没有引用后, 再释放,")]),a._v(" "),r("p",[a._v("mysql的checkpoint记录了mysql的LSN(日志序号号),\n恢复时从这个LSN开始即可\ntodo, checkpoint的时机")]),a._v(" "),r("h3",{attrs:{id:"日志"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#日志","aria-hidden":"true"}},[a._v("#")]),a._v(" 日志")]),a._v(" "),r("h4",{attrs:{id:"二进制日志"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二进制日志","aria-hidden":"true"}},[a._v("#")]),a._v(" 二进制日志")]),a._v(" "),r("p",[a._v("binlog在事务提交前, 一次性写入磁盘,\n不像redo分次提交, 因此binlog会对io造成一定压力\n理论上是先提交redo日志, 再提交binlog日志, 才算commit完成,\n与二进制日志区别()")]),a._v(" "),r("h3",{attrs:{id:"复制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#复制","aria-hidden":"true"}},[a._v("#")]),a._v(" 复制")]),a._v(" "),r("p",[a._v("备机io线程从主机的二进制日志读取到relay log,\nsql线程按照relay log写入数据库,")])])},[],!1,null,null,null);t.default=n.exports}}]);