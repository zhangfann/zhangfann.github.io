<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>flannel | 你好，世界！</title>
    <meta name="generator" content="VuePress 1.7.1">
    <script async="true" src="https://www.googletagmanager.com/gtag/js?id=UA-141019448-1"></script>
    <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
      
          gtag('config', 'UA-141019448-1');
      </script>
    <meta name="description" content="Hello World!">
    <meta name="baidu-site-verification" content="code-HRrK6kdBX1">
    
    <link rel="preload" href="/assets/css/0.styles.9b71556a.css" as="style"><link rel="preload" href="/assets/js/app.de73211e.js" as="script"><link rel="preload" href="/assets/js/2.3d8c79a8.js" as="script"><link rel="preload" href="/assets/js/73.9c0b1289.js" as="script"><link rel="prefetch" href="/assets/js/10.6d32f2e3.js"><link rel="prefetch" href="/assets/js/11.73ec703e.js"><link rel="prefetch" href="/assets/js/12.ca2ae098.js"><link rel="prefetch" href="/assets/js/13.e871368f.js"><link rel="prefetch" href="/assets/js/14.c1ae2477.js"><link rel="prefetch" href="/assets/js/15.0c4c0e6d.js"><link rel="prefetch" href="/assets/js/16.f77a8e69.js"><link rel="prefetch" href="/assets/js/17.4d4180f8.js"><link rel="prefetch" href="/assets/js/18.45c43172.js"><link rel="prefetch" href="/assets/js/19.d28459be.js"><link rel="prefetch" href="/assets/js/20.e6f7f320.js"><link rel="prefetch" href="/assets/js/21.f12bad6a.js"><link rel="prefetch" href="/assets/js/22.cdcbf09f.js"><link rel="prefetch" href="/assets/js/23.abc21202.js"><link rel="prefetch" href="/assets/js/24.73772214.js"><link rel="prefetch" href="/assets/js/25.15ab6a99.js"><link rel="prefetch" href="/assets/js/26.009d7c43.js"><link rel="prefetch" href="/assets/js/27.5c0a26c6.js"><link rel="prefetch" href="/assets/js/28.a67956b8.js"><link rel="prefetch" href="/assets/js/29.5aa2fd69.js"><link rel="prefetch" href="/assets/js/3.86da7cbc.js"><link rel="prefetch" href="/assets/js/30.6438cbbe.js"><link rel="prefetch" href="/assets/js/31.8a973da8.js"><link rel="prefetch" href="/assets/js/32.02ea44e0.js"><link rel="prefetch" href="/assets/js/33.255c66b6.js"><link rel="prefetch" href="/assets/js/34.3e99648e.js"><link rel="prefetch" href="/assets/js/35.1e940d16.js"><link rel="prefetch" href="/assets/js/36.946fd3d7.js"><link rel="prefetch" href="/assets/js/37.7eccff12.js"><link rel="prefetch" href="/assets/js/38.ae42c7a0.js"><link rel="prefetch" href="/assets/js/39.96f71642.js"><link rel="prefetch" href="/assets/js/4.04aa2cd9.js"><link rel="prefetch" href="/assets/js/40.24149921.js"><link rel="prefetch" href="/assets/js/41.a1efd1af.js"><link rel="prefetch" href="/assets/js/42.cdf79c91.js"><link rel="prefetch" href="/assets/js/43.49c91e4a.js"><link rel="prefetch" href="/assets/js/44.747a7d8a.js"><link rel="prefetch" href="/assets/js/45.f379c293.js"><link rel="prefetch" href="/assets/js/46.27a0d29c.js"><link rel="prefetch" href="/assets/js/47.e84b7f75.js"><link rel="prefetch" href="/assets/js/48.330f795a.js"><link rel="prefetch" href="/assets/js/49.74eb5526.js"><link rel="prefetch" href="/assets/js/5.3df56866.js"><link rel="prefetch" href="/assets/js/50.de446c48.js"><link rel="prefetch" href="/assets/js/51.b545b2ea.js"><link rel="prefetch" href="/assets/js/52.efe78a20.js"><link rel="prefetch" href="/assets/js/53.80d91f31.js"><link rel="prefetch" href="/assets/js/54.75ce3eea.js"><link rel="prefetch" href="/assets/js/55.2eb1e05a.js"><link rel="prefetch" href="/assets/js/56.53361058.js"><link rel="prefetch" href="/assets/js/57.5bba6263.js"><link rel="prefetch" href="/assets/js/58.289c5b9d.js"><link rel="prefetch" href="/assets/js/59.49eae599.js"><link rel="prefetch" href="/assets/js/6.afc4d923.js"><link rel="prefetch" href="/assets/js/60.43573dfc.js"><link rel="prefetch" href="/assets/js/61.108971d7.js"><link rel="prefetch" href="/assets/js/62.5a88d2b3.js"><link rel="prefetch" href="/assets/js/63.445d9f9a.js"><link rel="prefetch" href="/assets/js/64.7b38dfaa.js"><link rel="prefetch" href="/assets/js/65.c9c6873e.js"><link rel="prefetch" href="/assets/js/66.1f6c15dd.js"><link rel="prefetch" href="/assets/js/67.6eae7dc8.js"><link rel="prefetch" href="/assets/js/68.4278fb65.js"><link rel="prefetch" href="/assets/js/69.908b7197.js"><link rel="prefetch" href="/assets/js/7.9c101be4.js"><link rel="prefetch" href="/assets/js/70.3f57fee4.js"><link rel="prefetch" href="/assets/js/71.002a4453.js"><link rel="prefetch" href="/assets/js/72.c0a256e6.js"><link rel="prefetch" href="/assets/js/74.a736c83a.js"><link rel="prefetch" href="/assets/js/75.5c1c3aa4.js"><link rel="prefetch" href="/assets/js/76.d535ce03.js"><link rel="prefetch" href="/assets/js/77.d120b8dc.js"><link rel="prefetch" href="/assets/js/78.41e68585.js"><link rel="prefetch" href="/assets/js/79.178c9b9a.js"><link rel="prefetch" href="/assets/js/8.f2d60c3b.js"><link rel="prefetch" href="/assets/js/80.ad09d7b5.js"><link rel="prefetch" href="/assets/js/81.d27e94b6.js"><link rel="prefetch" href="/assets/js/82.bc7dba3f.js"><link rel="prefetch" href="/assets/js/9.7586d516.js">
    <link rel="stylesheet" href="/assets/css/0.styles.9b71556a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">你好，世界！</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/索引/Search.html" class="nav-link">
  Google站内搜索
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Select language" class="dropdown-title"><span class="title">选择语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="Select language" class="mobile-dropdown-title"><span class="title">选择语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/en/" class="nav-link">
  en-US
</a></li><li class="dropdown-item"><!----> <a href="/素材/210917_flannel.html" class="nav-link">
  简体中文
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/索引/Search.html" class="nav-link">
  Google站内搜索
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Select language" class="dropdown-title"><span class="title">选择语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="Select language" class="mobile-dropdown-title"><span class="title">选择语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/en/" class="nav-link">
  en-US
</a></li><li class="dropdown-item"><!----> <a href="/素材/210917_flannel.html" class="nav-link">
  简体中文
</a></li></ul></div></div> <!----></nav>  <!----> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>flannel</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/%E7%B4%A0%E6%9D%90/210917_flannel.html#背景-和-flannel-要解决的问题" class="sidebar-link">背景 和 flannel 要解决的问题</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E7%B4%A0%E6%9D%90/210917_flannel.html#runtime-方案设计" class="sidebar-link">runtime 方案设计</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E7%B4%A0%E6%9D%90/210917_flannel.html#tun-backend-udp" class="sidebar-link">TUN ( backend UDP )</a></li><li class="sidebar-sub-header"><a href="/%E7%B4%A0%E6%9D%90/210917_flannel.html#backend-vxlan" class="sidebar-link">backend VXLAN</a></li><li class="sidebar-sub-header"><a href="/%E7%B4%A0%E6%9D%90/210917_flannel.html#backend-host-gateway" class="sidebar-link">backend Host-Gateway</a></li><li class="sidebar-sub-header"><a href="/%E7%B4%A0%E6%9D%90/210917_flannel.html#runtime-方案设计-结" class="sidebar-link">runtime 方案设计 [结]</a></li></ul></li><li><a href="/%E7%B4%A0%E6%9D%90/210917_flannel.html#与-k8s-结合" class="sidebar-link">与 K8s 结合</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E7%B4%A0%E6%9D%90/210917_flannel.html#ref" class="sidebar-link">ref</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><blockquote><ul><li>因为笔者对 计算机网络 认识浅薄, 加上很多的部分都是现学现卖，所以下述内容可能存在与具体事实相悖的内容, 所以如果发现请劳烦指正或讨论! 不胜感激.</li> <li>下文中如下词汇表达同一个意思： 数据帧，数据包</li></ul></blockquote> <p>[TOC]</p> <h2 id="背景-和-flannel-要解决的问题"><a href="#背景-和-flannel-要解决的问题" class="header-anchor">#</a> 背景 和 flannel 要解决的问题</h2> <p>从 flannel 的角度看, Kubernetes 只提供了 CNI 接口, 而 flannel 要完成下层网络的连通和构建.</p> <p>flannel 要解决基于 CNI 的问题包括如下:</p> <ol><li>分配每个 Pods 的网络地址 (知道每个 Pods 在哪)</li> <li>设置虚拟网络设备, 来负责虚拟网络连通 (让数据包到达 指定 Pods 的位置)</li></ol> <p>除此之外, 它还要解决 Kubernetes 环境下对 网络方案的要求:</p> <ol><li>所有的 Pods 都需要有 独立的 IP 地址</li> <li>所有的 Pods 都需要可以对外发包并接收到响应</li> <li>合理划分子网, 避免 ARP 泛洪问题.</li> <li>可以动态的分配 IP 地址, 而不是静态的地址分配</li> <li>节点上的 Pod 可以不通过 NAT 和其他任何节点上的 Pod 通信</li> <li>节点上的代理（比如：系统守护进程、kubelet）可以和节点上的所有Pod通信</li></ol> <p>明确了要解决的问题后, 需要来写一些代码来解决这些问题, flannel 选择了构建 overlay 网络的方式来解决 Kubernetes 网络的搭建问题.</p> <h2 id="runtime-方案设计"><a href="#runtime-方案设计" class="header-anchor">#</a> runtime 方案设计</h2> <p>flannel 几乎是最早的跨节点容器解决方案，flannel 提供很多种的网络模式，除了等下要详细讲的 <code>UDP</code> \ <code>VXLAN</code> \ <code>Host-Gateway</code> 这三个模式外，还包括如下</p> <ul><li>平台绑定的网络模式 ： <code>AliVPC</code> \ <code>AWSVPC</code> \ <code>TencentVPC</code> \ <code>GCE Route</code></li> <li><code>IPIP</code> \ <code>IPSec</code></li> <li>仅限单机的 <code>Alloc</code></li></ul> <p>flannel 将 Pod 的 CIDR 网段与 机器绑定, 从而避免不必要的数据包转发.</p> <p><img src="https://kurisu-cc-1253443349.cos.ap-guangzhou.myqcloud.com/assets/flannel-07-arch-CIDR.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDmcLEhLf8xmVsMkrEVfIoEUaYQFxUr25y%26q-sign-time%3D1631850998%3B1637035058%26q-key-time%3D1631850998%3B1637035058%26q-header-list%3Dhost%26q-url-param-list%3D%26q-signature%3Dcfe46b74291c9e7f895b97cd32ca44fc00e108b4" alt="img"></p> <h3 id="tun-backend-udp"><a href="#tun-backend-udp" class="header-anchor">#</a> TUN ( backend UDP )</h3> <blockquote><p>在其他大部分文章里, 以及 flannel 的官方文档里, 都会把这一阶段称为 <code>UDP</code> ,但笔者认为这个描述有失准确性, 这里的关键事实上不是 UDP, VXLAN 也是使用 UDP 来进行数据包的四层封装, 笔者认为这个方案的核心在于 TUN 设备. 遂这一节的标题笔者将它取为 TUN</p></blockquote> <h4 id="设计"><a href="#设计" class="header-anchor">#</a> 设计</h4> <p>构建 overlay 网络, 最简单的方式自然是使用 TUN 来将 三层网络(L3) 的包抓上来, 然后由 应用层(L7) 重新封包 再投递. flannel 也是这么想的. 如下面的示意图所示,</p> <p><img src="https://kurisu-cc-1253443349.cos.ap-guangzhou.myqcloud.com/assets/flannel-01-arch-TUN.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDmcLEhLf8xmVsMkrEVfIoEUaYQFxUr25y%26q-sign-time%3D1631850998%3B1637035058%26q-key-time%3D1631850998%3B1637035058%26q-header-list%3Dhost%26q-url-param-list%3D%26q-signature%3Def1dbab972bcb1d0ae85e97232f56693290a3d63" alt="img"></p> <p>每个节点上会有一个 flannel 的 agent 叫做 <code>flanneld</code> , (下一章节会专门聊这个是如何预先配置到各个节点上的, 这里先专注在 Runtime 上) , 这个 Agent 会设置 router 和 开启 一个 tun 类型的网络设备 叫 <code>flannel 0</code> .</p> <p>网络包从 <code>Network Namespace</code> 中, 透过 <code>veth pair</code> 来到 <code>docker0 (bridge)</code> 之后, 数据包的 <code>目标 mac 地址</code> 已经到达 (mac 地址是一段一段改变的), 当前数据包结构如下</p> <div class="language- line-numbers-mode"><pre class="language-text"><code># current package format

---------------
mac(L2)
---------------
ip (L3)
---------------
L4 protocal format
---------------
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>所以 bridge 会将这个数据包交给 <code>Linux 协议栈</code> 来做 L3 层的路由, <code>Linux 协议栈</code> 发现 数据包中的 <code>目标地址 IP</code> 符合 <code>Linux Kernel FIB</code> 中的路由规则, 接着会将 数据包 转发给 <code>flannel 0 设备</code>, 而 <code>flannel 0</code> 是 tun 设备, 在 收到 数据包后 会以 <code>L3 数据包</code> 的格式将 数据包 发给 flanneld 程序. 当前数据包结构如下</p> <div class="language- line-numbers-mode"><pre class="language-text"><code># current package format

---------------
ip (L3)
---------------
L4 protocal format
---------------
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>flanneld 程序会读取 收到的数据包 的 <code>目标 IP</code>, 根据 etcd 中的各 flannel 节点的 <code>网段信息</code> 判断 这个数据包要发给哪一个其他的 flanneld 程序.</p> <p>etcd 中的一个网段信息对应一个节点, 每个节点上会有一个 flanneld 程序, 而 etcd 中实际存储的就是一个网段信息对应一个 flanneld 程序的 IP 地址.</p> <p>所以 flanneld 程序根据 etcd 中的 <code>网段信息</code> 知道了 数据包 的接受者在哪个节点之后, 就会将 数据包使用 UDP 的格式重新封包, 然后发送给对应节点的 flanneld 所监听的端口上. 当前数据包结构如下</p> <div class="language- line-numbers-mode"><pre class="language-text"><code># current package format

---------------
UDP (L4)
---------------
ip (L3)
---------------
L4 protocal format
---------------
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><img src="https://kurisu-cc-1253443349.cos.ap-guangzhou.myqcloud.com/assets/flannel-01-arch-TUN.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDmcLEhLf8xmVsMkrEVfIoEUaYQFxUr25y%26q-sign-time%3D1631850998%3B1637035058%26q-key-time%3D1631850998%3B1637035058%26q-header-list%3Dhost%26q-url-param-list%3D%26q-signature%3Def1dbab972bcb1d0ae85e97232f56693290a3d63" alt="img"></p> <p>接着数据包流经 当前节点的 eth0 网卡发送出去, 当前数据包结构如下</p> <div class="language- line-numbers-mode"><pre class="language-text"><code># current package format

---------------
Mac (L2)
---------------
other flanneld ip (L3)
---------------
UDP (L4)
---------------
ip (L3)
---------------
L4 protocal format
---------------
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>接着对端的 eth0 网卡接受到数据后, 开始将数据包解包, 在 L4 层发现是 Node B 上的 flanneld 监听的端口, 然后将 数据包透过 socket 的形式传输给 flanneld, 接着 flanneld 收到 eth0 给过来的数据包后, 当前数据包结构如下</p> <div class="language- line-numbers-mode"><pre class="language-text"><code># current package format

---------------
ip (L3)
---------------
L4 protocal format
---------------
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>将数据包再给回 flannel 0 这个 TUN 设备, TUN 设备会把这个包放回 L3 的协议栈中, 协议栈会去根据 Linux Kernel FIB 中的命中规则, 将 数据包发送 给 docker 0 , 然后 docker 0 完成 ip 到 mac 地址的转换, 将 数据包从对应的 veth pair 传输到 <code>network namespace</code> 中, 接着在 Linux 的协议栈 L4 拆包时, 将数据包给到 Biz App. 当前数据包结构如下</p> <div class="language- line-numbers-mode"><pre class="language-text"><code># current package format

---------------
L4 protocal format
---------------
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img src="https://kurisu-cc-1253443349.cos.ap-guangzhou.myqcloud.com/assets/flannel-01-arch-TUN.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDmcLEhLf8xmVsMkrEVfIoEUaYQFxUr25y%26q-sign-time%3D1631850998%3B1637035058%26q-key-time%3D1631850998%3B1637035058%26q-header-list%3Dhost%26q-url-param-list%3D%26q-signature%3Def1dbab972bcb1d0ae85e97232f56693290a3d63" alt="img"></p> <p>这样就是 flannel 在 TUN 模式下, 数据包传输的全过程, 可以看到使用一个较为简单的结构, 以 overlay 的形式, 解决了 Kubernetes 网络的搭建.</p> <h4 id="结"><a href="#结" class="header-anchor">#</a> 结</h4> <p>虽然 flannel 的 TUN 方案存在一些不小的缺陷(性能方面), 但可以看得出这个方案的潜力,</p> <ul><li>通过以 节点维度 的网段划分, 来避免了要精确找到每个 IP 对应的 容器在哪的 问题 <s>(拯救大兵瑞恩 😃)</s>, 我们只需要知道这个节点对应的网段, 就可以知道这个数据包要发到哪个 flannel agent 上, 剩下的由 对应节点内部自行确定 数据包的接收容器. 虽然这个不一定是 flannel 首创, 可能在 传统的 VM 的网络方案中 就已经有. 但这是一个很棒的解决方案.</li></ul> <p>不过这个模式依旧存在缺陷, 主要是性能方面, 由于大量使用了 TUN 网络设备, 每发送一个数据包每次都会经历两次从 <code>用户态</code> 到 <code>内核态</code> 的切换,</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>  TUN ========&gt; flanneld =======&gt; eth 0
 内核态           用户态             内核态
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这会造成不小的性能损耗, 接着尝试对这块做优化.</p> <h3 id="backend-vxlan"><a href="#backend-vxlan" class="header-anchor">#</a> backend VXLAN</h3> <p>可以看到 基于 TUN 的方案其实已经解决问题了(<s>又不是不能用 😃</s>), 接着需要去优化性能以适配对性能更加敏感的场景. TUN 模式下的问题在于 在用户态下, 对 数据包重新封装, 从而带来的性能问题. 那么是否有可能将这个重新封装的工作在 内核态 下完成呢? 这里 flannel 选择使用 Kernel 中的 VXLAN , 来代替刚刚 TUN 模式 的实现.在现在, VXLAN 已经变成了一个模式架构的代名词, 例如你可以使用 OVS(open vSwitch) 来实现一个 VXLAN , 但我们这里讨论的是 Linux Kernel 中的 VXLAN 实现.</p> <h4 id="设计-2"><a href="#设计-2" class="header-anchor">#</a> 设计</h4> <p>VXLAN 透过和上述 TUN 模式类似的结构实现了一个 Overlay 网络, 它会在每个节点上有一个叫做 VTEP (VXLAN Tunnel Endpoint) 的 agent , 这个 agent 运行在内核态下. VXLAN 有组播模式, 以及 VNI 的概念,</p> <p><img src="http://support.huawei.com/huaweiconnect/enterprise/data/attachment/forum/dm/ecommunity/uploads/2015/1123/16/5652c940898f4.png" alt="img"></p> <p>而读者从上面的描述里也看得到, flannel 仅仅只是想透过 VXLAN 性能而已, 并不是希望透过 VXLAN 来提供新的 feature , 所以 flannel 这里只是最简单的使用了 VXLAN, 比如 VNI 默认为 <code>1</code>, VTEP 不分组, 所有的 VTEP 都是一个组, 并且 flannel 会手动维护 VTEP 的 FDB(mac to ip) 表 和 ARP (ip to mac)表.</p> <p><img src="https://kurisu-cc-1253443349.cos.ap-guangzhou.myqcloud.com/assets/flannel-02-arch-VXLAN.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDmcLEhLf8xmVsMkrEVfIoEUaYQFxUr25y%26q-sign-time%3D1631850998%3B1637035058%26q-key-time%3D1631850998%3B1637035058%26q-header-list%3Dhost%26q-url-param-list%3D%26q-signature%3Dcede62736c78d4ed900aa38e06d8c3f68cc373a1" alt="img"></p> <p>在前面的流程都类似, 从 <code>Network Namespace</code> 出来, 经过 docker 0 / CNI 0 , 然后来到 <code>Linux Kernel FIB</code>, 匹配到路由规则, 将数据包丢给 flannel.1 , 在这里 透过 flanneld 以及 flanneld 维护的 FDB 以及 ARP 表, 按照 VXLAN 的方式包装后, 将数据包丢给 Node B, 接着 Node B 里的 VTEP 进行解包, 然后将数据透过 Linux Kernel Router 中的路由给到 docker0 / cni0 bridge , 接着再通过 veth pair 给到 实际的应用程序.</p> <h4 id="结-2"><a href="#结-2" class="header-anchor">#</a> 结</h4> <p>看起来这里的转发链条短了一些, 并且转发效率比 TUN 方案好一些,整个过程完全在内核态完成, flanneld 并不直接参与转发过程, 只是负责进行配置.</p> <p>但是由于 VXLAN 本身就有一定的复杂性, 让它的加入使得 flannel 的复杂度又稍有上升. flannel 在 FDB 和 ARP 表的维护问题上改进了两次方案, 起初是让 VTEP 自动学习, 最后干脆直接让 flanneld 自行手动维护.</p> <h3 id="backend-host-gateway"><a href="#backend-host-gateway" class="header-anchor">#</a> backend Host-Gateway</h3> <h4 id="设计-3"><a href="#设计-3" class="header-anchor">#</a> 设计</h4> <p>其实本质上, 也就只是想把 数据包 转发到对应的节点上, 然后让那个节点自行将 数据包 投递到对应的容器中, 那么我们能不能让对应的节点作为网关呢?</p> <p><img src="https://kurisu-cc-1253443349.cos.ap-guangzhou.myqcloud.com/assets/flannel-03-arch-host-gateway.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDmcLEhLf8xmVsMkrEVfIoEUaYQFxUr25y%26q-sign-time%3D1631850998%3B1637035058%26q-key-time%3D1631850998%3B1637035058%26q-header-list%3Dhost%26q-url-param-list%3D%26q-signature%3D991f6f996ddce54a1690f2f3c0ad94aaa50314f7" alt="img"></p> <p>flannel 就是这么做的, flanneld 会配置 路由规则在 <code>Linux Kernel FIB</code> 上, 但是这次它会把 Node B 对应的路由网关设置为 Node B的 IP, 并创建另一个网卡 eth1, 并且在 eth 1 的网段设置上, 故意和原有的 eth0 错开网段, 当 Node A 的 <code>Linux Kernel FIB</code> 想直接转发数据包给 Node B 的时候, 发现这是另一个网段的包, 它尚未知道 Node B 的 Mac 地址, 所以 Node A 会将数据包传给 对应的 网关, 数据包就直接给到 Node B, 这个时候 Node B 只需要将数据包投递给对应的容器即可, 可以看到方案的变得简单了很多.</p> <p>Node A 的路由表大致长这样子</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>10.244.0.0        0.0.0.0                255.255.255.0 u 0 0 0 cni0
10.244.1.0        172.16.139.150        255.255.255.0 u 0 0 0 eth1
10.244.2.0        172.16.139.154        255.255.255.0 u 0 0 0 eth1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在 host-gateway 模式后, flanneld 的作用就只有刷新每个节点上的 路由表了.</p> <h4 id="结-3"><a href="#结-3" class="header-anchor">#</a> 结</h4> <p>由于 Host-Gateway 会指定对应的节点 IP 作为网关, 那么它就要求所有的节点必须在一个子网范围内, 不然脱离了当前的子网, 则需要另行配置上层网络的路由规则, 但 flannel 无法控制上层网络, 这将使 flannel 变得复杂, 所以 Host-Gateway 方案只支持在同一个子网内, 不过这个条件在 K8s 上, 集群规模不大的话, 还是很容易达成的.</p> <h3 id="runtime-方案设计-结"><a href="#runtime-方案设计-结" class="header-anchor">#</a> runtime 方案设计 [结]</h3> <p>从笔者的角度在总结的话, TUN 方案笔者认为更像一个完成需求的 MVP(最小可行性模型), 虽然能够完成需求, 但是有一定的缺陷, 我觉得 CoreOS 的工程师一定知道在用户态下处理网络包会出现性能问题, 即便如此, 他们还是这么做了, flannel 是一个很早就出现的 K8s 网络方案, 可以看出他们的探索模式还是挺值得学习的.</p> <p>接着再对这个 MVP 优化, 借助 VXLAN 的力量, 将整个业务流程完全拉到内核态下, 就避免了用户态和 内核态切换的性能耗损, 但也无可避免需要消化 VXLAN 的复杂性. 你可以看到 flannel 只使用了 VXLAN 很小的一部分功能, VNI 直接永远设为 1 , FDB 和 ARP 都是手动维护的.</p> <p>随后, 可能是有了灵感, 直接将 对应的节点作为 网关, 这样就解决了转发的复杂性, 并且由于是直接路由转发的方案, 性能也是有保证的.</p> <p>再随后, flannel 还做了 例如 <code>ipip转发</code>(host-gw 的再改进版), <code>ipsec</code> 等的方案, 这些方案的思路和上述方案的思路类似, 这里就不赘述.</p> <h2 id="与-k8s-结合"><a href="#与-k8s-结合" class="header-anchor">#</a> 与 K8s 结合</h2> <p>大多数的文章写到这里就停了, 但其实只介绍 flannel 的 runtime 是没有办法和 K8s 相关知识串起来的, 还需要了解 flannel 是如何 支持 CNI 来达成和 K8s 协作的.</p> <p>首先, flannel 本身和 CNI 是无关的, flannel 会有 一个 cni-plugins 专门与 cni 交互. 我们透过 K8s 拉取的 flannel 镜像, 首先会有一个 Init Container 将CNI 的 配置信息 copy 到本机的对应的位置. 会运行 flanneld, 然后在 /etc/flannel/subnet.env 中写入当前机器分配到的子网信息, 接着 flanneld 根据所设置的 flannel 模式, 会进行自己的工作.</p> <p><img src="https://kurisu-cc-1253443349.cos.ap-guangzhou.myqcloud.com/assets/flannel-05-arch-CNI-Timing-deploying.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDmcLEhLf8xmVsMkrEVfIoEUaYQFxUr25y%26q-sign-time%3D1631850998%3B1637035058%26q-key-time%3D1631850998%3B1637035058%26q-header-list%3Dhost%26q-url-param-list%3D%26q-signature%3D2899bbd53072cea0bbb408daa86e5974e1ef84d9" alt="img"></p> <p>接着, 在创建容器的时候, CRI 的实现, 例如 containerd , 会调用 CNI 的接口, 要求 CNI 去生成一份 容器的网络信息, 这时 CNI 读取本机的 CNI 配置, 去通过 Shell 命令执行 CNI 中写的 CNI plugins, 这个时候会启动 flannel 的 cni plugins, 这个程序会根据读取 flannel 写在 <code>/etc/flannel/subnet.env</code> 的子网信息, 然后读取 CNI 的配置信息, 接着还是调用 CNI 的库, 将这些配置信息传给 CNI 方法, 接着 CNI 的方法会调用配置的工具进行 <code>bridge</code>, <code>veth pair</code> 等网络设备的创建, 然后调用注册的 IPAM 程序分配 IP 地址 (默认是 <code>host-local</code> ), 在一切就绪后, 会将 IP地址等信息通过标准输出给回 CRI 中调用的 CNI 的方法, 然后 CNI 的 function 序列化数据后, 将数据返回给 CRI 插件. 时序图如下:</p> <p><img src="https://kurisu-cc-1253443349.cos.ap-guangzhou.myqcloud.com/assets/flannel-06-arch-CNI-Timing-running.png?sign=q-sign-algorithm%3Dsha1%26q-ak%3DAKIDmcLEhLf8xmVsMkrEVfIoEUaYQFxUr25y%26q-sign-time%3D1631850998%3B1637035058%26q-key-time%3D1631850998%3B1637035058%26q-header-list%3Dhost%26q-url-param-list%3D%26q-signature%3D1c21960ef2afd8946fc1fedaaf46375330207034" alt="img"></p> <p>你可以看到 flannel 并不是强绑定 K8s 的, flannel 只是依赖 etcd . 大多数的 K8s 的网络方案自身也支持 为虚拟机提供服务.</p> <h2 id="ref"><a href="#ref" class="header-anchor">#</a> ref</h2> <ul><li><a href="https://www.hwchiu.com/cni-flannel-ii.html" target="_blank" rel="noopener noreferrer">CNI - Flannel - IP 管理篇 - hwchiu<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://jimmysong.io/kubernetes-handbook/concepts/cni.html" target="_blank" rel="noopener noreferrer">CNI -jimmysong<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p>If you need to discuss, you can go to <a href="https://github.com/Kuri-su/KBlog" target="_blank" rel="noopener noreferrer">Kuri-su/KBlog<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> to make an issue.</p> <p>This article is licensed under a <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="noopener noreferrer">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0) License<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <p>Powered By Amatist_Kurisu and Jcc/Blog ❤  |  Designed By Amatist_Kurisu ❤  |  Cover Image From 井波ハトコ ❤</p> <p><a href="https://kuricat.com/link" target="_blank" rel="noopener noreferrer">LINKS<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://kuricat.com/rss" target="_blank" rel="noopener noreferrer">RSS<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>© Amatist_Kurisu 2018-2020. All rights reserved.</p> <iframe name="rpJSFrame" allowtransparency="true" style="box-sizing:border-box;max-width:100%;margin:0px !important;width:30px;height:150px;min-height:0px;border:0px;display:block !important;"></iframe></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2021/9/17 下午6:06:25</span></div></footer> <!----> </main> <div class="footer-wrapper footer"><span><a href="https://beian.miit.gov.cn/">豫ICP备20003255号</a></span> <!----></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.de73211e.js" defer></script><script src="/assets/js/2.3d8c79a8.js" defer></script><script src="/assets/js/73.9c0b1289.js" defer></script>
  </body>
</html>
