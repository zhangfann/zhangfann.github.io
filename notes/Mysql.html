<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>简介 | 张凡的笔记</title>
    <meta name="description" content="种一棵树最好的时间是十年前，其次是现在">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.d429b60d.css" as="style"><link rel="preload" href="/assets/js/app.f84e7e9e.js" as="script"><link rel="preload" href="/assets/js/2.3a03d1d4.js" as="script"><link rel="preload" href="/assets/js/12.76d112c9.js" as="script"><link rel="prefetch" href="/assets/js/10.672c215c.js"><link rel="prefetch" href="/assets/js/11.e3e1753c.js"><link rel="prefetch" href="/assets/js/13.37ef5037.js"><link rel="prefetch" href="/assets/js/14.90348d63.js"><link rel="prefetch" href="/assets/js/3.d7c6e660.js"><link rel="prefetch" href="/assets/js/4.206dbc5a.js"><link rel="prefetch" href="/assets/js/5.248d0955.js"><link rel="prefetch" href="/assets/js/6.e3c11ef8.js"><link rel="prefetch" href="/assets/js/7.1e0d218f.js"><link rel="prefetch" href="/assets/js/8.cca41018.js"><link rel="prefetch" href="/assets/js/9.d70a76da.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d429b60d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">张凡的笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/notes/" class="nav-link router-link-active">笔记</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/notes/" class="nav-link router-link-active">笔记</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>需求文档</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>我参与的项目</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>经典开源项目学习</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/mysql.html" class="active sidebar-link">Mysql</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/mysql.html#简介" class="sidebar-link">简介</a></li><li class="sidebar-sub-header"><a href="/notes/mysql.html#架构设计" class="sidebar-link">架构设计</a></li><li class="sidebar-sub-header"><a href="/notes/mysql.html#系统设计" class="sidebar-link">系统设计</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/mysql.html#主线程" class="sidebar-link">主线程</a></li><li class="sidebar-sub-header"><a href="/notes/mysql.html#b-索引" class="sidebar-link">B+索引</a></li><li class="sidebar-sub-header"><a href="/notes/mysql.html#表" class="sidebar-link">表</a></li><li class="sidebar-sub-header"><a href="/notes/mysql.html#并发" class="sidebar-link">并发</a></li><li class="sidebar-sub-header"><a href="/notes/mysql.html#事务" class="sidebar-link">事务</a></li><li class="sidebar-sub-header"><a href="/notes/mysql.html#复制" class="sidebar-link">复制</a></li><li class="sidebar-sub-header"><a href="/notes/mysql.html#日志" class="sidebar-link">日志</a></li></ul></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="简介"><a href="#简介" aria-hidden="true" class="header-anchor">#</a> 简介</h2> <h2 id="架构设计"><a href="#架构设计" aria-hidden="true" class="header-anchor">#</a> 架构设计</h2> <p><img src="/mysql/arch.bmp" alt="pic"></p> <h2 id="系统设计"><a href="#系统设计" aria-hidden="true" class="header-anchor">#</a> 系统设计</h2> <h3 id="主线程"><a href="#主线程" aria-hidden="true" class="header-anchor">#</a> 主线程</h3> <h4 id="主循环"><a href="#主循环" aria-hidden="true" class="header-anchor">#</a> 主循环</h4> <p>主循环分为每1s操作, 和每10s操作</p> <p>每1s操作,
重做日志刷新到磁盘,
如果io压力小,
合并插入缓冲,
如果脏页超过阈值,
刷新100脏页到磁盘,
如果用户无活动,
进入后台循环</p> <p>每10s操作,
重做日志刷新到磁盘,
合并插入缓冲,
删除无用undo页,
刷新100脏页到磁盘,
产生一个检查点,</p> <h4 id="后台循环"><a href="#后台循环" aria-hidden="true" class="header-anchor">#</a> 后台循环</h4> <p>后台循环, 数据库空闲时调用,
合并插入缓冲,
删除无用undo页,
如果非空闲,
进入主循环,
否则进入刷新循环</p> <h4 id="刷新循环"><a href="#刷新循环" aria-hidden="true" class="header-anchor">#</a> 刷新循环</h4> <p>刷新100脏页到磁盘,
如果脏页仍超过阈值,
继续刷新循环</p> <h3 id="b-索引"><a href="#b-索引" aria-hidden="true" class="header-anchor">#</a> B+索引</h3> <h4 id="插入"><a href="#插入" aria-hidden="true" class="header-anchor">#</a> 插入</h4> <p>B+树插入分为3种情况</p> <ul><li>leaf page未满, 索引页未满, 直接将记录插入leaf page</li> <li>leaf page满, index page未满,
<ul><li>拆分leaf page</li> <li>将中间的记录放入index page</li> <li>小于中间节点的记录放入左边</li> <li>大于等于中间节点的记录放入右边</li></ul></li> <li>leaf page满, index page满
<ul><li>拆分leaf page</li> <li>小于中间节点的放左边</li> <li>大于等于中间节点的记录放右边</li> <li>拆分index page</li> <li>小于中间节点的记录放左边</li> <li>大于中间节点的记录放右边</li> <li>中间节点放入上层index page</li></ul></li></ul> <p>例子</p> <p>初始状态
<img src="/mysql/b_insert_1.bmp" alt="初始状态"></p> <p>插入28, 叶节点没满, 直接插入
<img src="/mysql/b_insert_2.bmp" alt="插入28"></p> <p>插入70, 索引节点没满, 插到第三个节点, 并将第三个节点拆分
<img src="/mysql/b_insert_3.bmp" alt="插入70"></p> <p>插入95, 到最右节点, 最右节点拆分, 中位数到索引节点, 索引节点再拆分
<img src="/mysql/b_insert_4.bmp" alt="插入95"></p> <p>兄弟节点合并
<img src="/mysql/b_insert_5.bmp" alt="合并"></p> <h4 id="删除"><a href="#删除" aria-hidden="true" class="header-anchor">#</a> 删除</h4> <p>删除分为3种情况</p> <ul><li>leaf page在阈值上, index page在阈值上,
直接将记录从叶节点删除, 如果该节点在index page中,
用该节点的右节点替代</li> <li>leaf page在阈值下, index page在阈值下,
合并叶节点及其兄弟节点, 更新index节点</li> <li>leaf page在阈值下, index page在阈值下
<ul><li>合并叶节点及其兄弟节点</li> <li>更新index page</li> <li>合并index page及其兄弟节点</li></ul></li></ul> <p>例子</p> <p>初始状态
<img src="/mysql/b_insert_4.bmp" alt="插入95"></p> <p>删除70, 直接删除
<img src="/mysql/b_delete_2.bmp" alt="删除70"></p> <p>删除25, 删除后索引节点中更新一下
<img src="/mysql/b_delete_3.bmp" alt="删除25"></p> <p>删除60, 叶节点和索引节点分别进行合并
<img src="/mysql/b_delete_4.bmp" alt="删除25"></p> <h4 id="聚集索引-辅助索引"><a href="#聚集索引-辅助索引" aria-hidden="true" class="header-anchor">#</a> 聚集索引, 辅助索引</h4> <p>聚集索引以主键为索引, 存全部数据,
辅助索引, 以其他键为索引, 只存部分数据, 并给出主键,
完整数据还需要根据主键查找聚集索引,</p> <p>如果取大量数据, mysql也许不会使用索引,
或者有些列上没有建立索引,
此时, 就需要通过遍历的方式</p> <h4 id="联合索引"><a href="#联合索引" aria-hidden="true" class="header-anchor">#</a> 联合索引</h4> <p>两个以上列组成的索引,
排列时, 先比较第1位, 然后第2位 …</p> <h4 id="自适应哈希"><a href="#自适应哈希" aria-hidden="true" class="header-anchor">#</a> 自适应哈希</h4> <p>键值(主键或其他键)直接对于数据行,
自适应哈希主要是查找select * from xxtable where key=xxkey,
擅长精准查找, 但是不能范围查找</p> <h3 id="表"><a href="#表" aria-hidden="true" class="header-anchor">#</a> 表</h3> <h4 id="段"><a href="#段" aria-hidden="true" class="header-anchor">#</a> 段</h4> <p>段分为数据段, 索引段,
innodb存储引擎是索引组织的,
数据即索引, 索引即数据,
数据是b+树的叶节点, 索引是b+树的非叶节点</p> <h4 id="页"><a href="#页" aria-hidden="true" class="header-anchor">#</a> 页</h4> <p>mysql中先通过b+树找到记录所在的页,
然后在页中再利用page directory中通过二叉查找, 找到具体记录,</p> <h4 id="约束"><a href="#约束" aria-hidden="true" class="header-anchor">#</a> 约束</h4> <p>完整性
实体完整性, 保证唯一主键
域完整性, 保证值都是特定类型
参照完整性, 保证两张表间的外键关系,</p> <h4 id="触发器"><a href="#触发器" aria-hidden="true" class="header-anchor">#</a> 触发器</h4> <p>在insert/delete/update的before或after调用,
对数据进行检查,</p> <h3 id="并发"><a href="#并发" aria-hidden="true" class="header-anchor">#</a> 并发</h3> <h4 id="锁"><a href="#锁" aria-hidden="true" class="header-anchor">#</a> 锁</h4> <p>mysql读取数据时, 对该数据记录一个版本号,
之后事务中, 每次都读取该版本号数据,
更新时, mysql会读取事务版本号和当前mysql中最新版本号,
相同, 则进行更新, 否则回滚失败,</p> <h4 id="死锁"><a href="#死锁" aria-hidden="true" class="header-anchor">#</a> 死锁</h4> <p>一个例子
t1: select a=1 for update, t1把1锁住,
t2: select a=2 for update, t2把2锁住,
t1: select a=2 for update, t1等待t2,
t2: select a=1 for update, t2等待t1</p> <h4 id="隔离级别"><a href="#隔离级别" aria-hidden="true" class="header-anchor">#</a> 隔离级别</h4> <p>读未提交： 可以及时读到及时数据,
Read Uncommitted，顾名思义，就是一个事务可以读取另一个未提交事务的数据。最低级别，它存在 4 个常见问题（脏读、不可重复读、幻读、丢失更新）。</p> <p>读已提交： 读最新版历史数据,
Read Committed，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。 它解决了脏读问题，存在 3 个常见问题（不可重复读、幻读、丢失更新）。</p> <p>可重复读： 读固定版历史数据,
Repeatable Read，就是在开始读取数据（事务开启）时，不再允许修改操作 。它解决了脏读和不可重复读，还存在 2 个常见问题（幻读、丢失更新）。</p> <p>丢失更新,
mysql一般是可重复读的, 对于丢失更新, 它的解决方式是
读取历史版本数据时, 同时记录版本号,
在更新时, 如果版本号相同, 进行更新,
版本号不同, 更新失败,</p> <p>幻读,
事务select一个数据, 发现数据不存在, 插入时, 发现数据已存在,
大部分幻读是可以接受的,
要想避免可以使用select … for update,</p> <p>序列化： 完全顺序读
Serializable，序列化，或串行化。就是将每个事务按一定的顺序去执行，它将隔离问题全部解决，但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p> <h3 id="事务"><a href="#事务" aria-hidden="true" class="header-anchor">#</a> 事务</h3> <p>acid</p> <p>原子性, 要么全做, 要么全不做,</p> <p>一致性, 保证主键, 外键, 数据类型等约束符合定义,</p> <p>隔离性, 客户端任何时刻都可以认为只有自己在操作,</p> <p>持久性, 只要事务返回成功, 那么它一定成功更新了数据库, 无论数据库之后是否挂了</p> <h4 id="重做日志"><a href="#重做日志" aria-hidden="true" class="header-anchor">#</a> 重做日志</h4> <p>redo log和undo log在功能上经常一起使用,
在理论上, 也都是事务日志的概念,
所以可以将二者视为同一日志,
不过redo log记录新值, 实现持久性,
undo log记录旧值, 实现原子性,</p> <p>redo log记录在磁盘的文件中,
ib_logfile0, ib_logfile1,
记录了事务, 对于数据恢复非常重要,
重做日志从缓存刷向磁盘时, 在ib_logfile0和ib_logfile1之间循环写入</p> <p>与二进制日志区别,
二进制日志记录所有与mysql相关的内容, 以及具体操作,
而且在提交事务前记录,
重做日志, 记录每个页改变的物理情况
在事务进行过程中, 不断提交</p> <h4 id="undo页"><a href="#undo页" aria-hidden="true" class="header-anchor">#</a> undo页</h4> <p>undo页记录了历史数据,
一个作用是事务读取数据时, 提供历史版本数据,
另个作用是死锁时, 进行回滚,</p> <p>undo记录的是逻辑信息,
比如对于每个insert记录一个delete,
对于每个update, 记录一个复原的update</p> <p>在事务commit后, 会被标记为无用的undo页,</p> <h4 id="wal"><a href="#wal" aria-hidden="true" class="header-anchor">#</a> WAL</h4> <p>在对数据修改前, 记录undo log, 修改后, 记录redo log,
事务提交前, 只向磁盘写redo log
undo log和数据都不向磁盘写, 这样可以减少io
当脏页刷入磁盘, redo log就没有用了,</p> <p>redo log只能追加, 并且为了io性能, 会多个事务写入同一日志,
因此会造成未提交事务也写入redo 日志,
在恢复时, 会重做所有redo log,
其中未记录commit的事务,
会通过undo log回滚,
理论上commit后, undo就没用了,
但由于mvcc, 其他事务可能还依赖undo信息,
所以需要等到undo信息没有引用后, 再释放,</p> <p>mysql的checkpoint记录了mysql的LSN(日志序号号),
恢复时从这个LSN开始即可,</p> <h3 id="复制"><a href="#复制" aria-hidden="true" class="header-anchor">#</a> 复制</h3> <p>备机io线程从主机的二进制日志读取到relay log,
sql线程按照relay log写入数据库,</p> <h3 id="日志"><a href="#日志" aria-hidden="true" class="header-anchor">#</a> 日志</h3> <h4 id="二进制日志"><a href="#二进制日志" aria-hidden="true" class="header-anchor">#</a> 二进制日志</h4> <p>binlog在事务提交前, 一次性写入磁盘,
不像redo分次提交, 因此binlog会对io造成一定压力
理论上是先提交redo日志, 再提交binlog日志, 才算commit完成,</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/notes/vipserver.html" class="prev">
          Vipserver(天枢)
        </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f84e7e9e.js" defer></script><script src="/assets/js/2.3a03d1d4.js" defer></script><script src="/assets/js/12.76d112c9.js" defer></script>
  </body>
</html>
