<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>简介 | 张凡的笔记</title>
    <meta name="description" content="种一棵树最好的时间是十年前，其次是现在">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.d429b60d.css" as="style"><link rel="preload" href="/assets/js/app.eaee92e7.js" as="script"><link rel="preload" href="/assets/js/2.3a03d1d4.js" as="script"><link rel="preload" href="/assets/js/10.ff8394e1.js" as="script"><link rel="prefetch" href="/assets/js/11.ee8006dc.js"><link rel="prefetch" href="/assets/js/12.39477915.js"><link rel="prefetch" href="/assets/js/13.60741dd3.js"><link rel="prefetch" href="/assets/js/3.d7c6e660.js"><link rel="prefetch" href="/assets/js/4.206dbc5a.js"><link rel="prefetch" href="/assets/js/5.248d0955.js"><link rel="prefetch" href="/assets/js/6.b4bf4fa0.js"><link rel="prefetch" href="/assets/js/7.cfe561a8.js"><link rel="prefetch" href="/assets/js/8.0f026308.js"><link rel="prefetch" href="/assets/js/9.f5c15655.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d429b60d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">张凡的笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/notes/" class="nav-link router-link-active">笔记</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/notes/" class="nav-link router-link-active">笔记</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>我参与的项目</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>经典开源项目学习</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/notes/Mysql.html" class="active sidebar-link">Mysql</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/Mysql.html#架构设计" class="sidebar-link">架构设计</a></li><li class="sidebar-sub-header"><a href="/notes/Mysql.html#系统设计" class="sidebar-link">系统设计</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/notes/Mysql.html#主线程" class="sidebar-link">主线程</a></li><li class="sidebar-sub-header"><a href="/notes/Mysql.html#索引" class="sidebar-link">索引</a></li><li class="sidebar-sub-header"><a href="/notes/Mysql.html#聚集索引-辅助索引" class="sidebar-link">聚集索引, 辅助索引</a></li><li class="sidebar-sub-header"><a href="/notes/Mysql.html#联合索引" class="sidebar-link">联合索引</a></li><li class="sidebar-sub-header"><a href="/notes/Mysql.html#自适应哈希" class="sidebar-link">自适应哈希</a></li><li class="sidebar-sub-header"><a href="/notes/Mysql.html#表" class="sidebar-link">表</a></li><li class="sidebar-sub-header"><a href="/notes/Mysql.html#锁" class="sidebar-link">锁</a></li><li class="sidebar-sub-header"><a href="/notes/Mysql.html#事务" class="sidebar-link">事务</a></li><li class="sidebar-sub-header"><a href="/notes/Mysql.html#日志" class="sidebar-link">日志</a></li><li class="sidebar-sub-header"><a href="/notes/Mysql.html#复制" class="sidebar-link">复制</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>其他技术文章</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="简介"><a href="#简介" aria-hidden="true" class="header-anchor">#</a> 简介</h1> <h2 id="架构设计"><a href="#架构设计" aria-hidden="true" class="header-anchor">#</a> 架构设计</h2> <p><img src="/mysql/mysql_arch.png" alt="pic"></p> <h2 id="系统设计"><a href="#系统设计" aria-hidden="true" class="header-anchor">#</a> 系统设计</h2> <h3 id="主线程"><a href="#主线程" aria-hidden="true" class="header-anchor">#</a> 主线程</h3> <p>主线程</p> <p>主循环</p> <p>后台循环</p> <p>刷新循环</p> <p>暂停循环</p> <h4 id="主循环"><a href="#主循环" aria-hidden="true" class="header-anchor">#</a> 主循环</h4> <p>每1s操作,
重做日志刷新到磁盘,
如果io压力小,
合并插入缓冲,
如果脏页超过阈值,
刷新100脏页到磁盘,
刷新脏页(),
如果用户无活动,
后台循环</p> <p>每10s操作,
重做日志刷新到磁盘,
合并插入缓冲,
删除无用undo页,
刷新100脏页到磁盘,
// 与二次写有关,
刷新脏页(),
产生一个检查点,</p> <p>后台循环, 数据库空闲时调用,
后台循环的操作都是内存态的,
合并插入缓冲,
删除无用undo页,
如果非空闲,
主循环,
否则刷新循环</p> <p>刷新循环
刷新循环主要是与磁盘交互,
刷新100脏页到磁盘,
刷新脏页(),
如果脏页超过阈值,
刷新循环</p> <p>暂停循环</p> <h3 id="索引"><a href="#索引" aria-hidden="true" class="header-anchor">#</a> 索引</h3> <p><img src="/mysql/b1.png" alt="pic"> <img src="/mysql/b2.png" alt="pic"> <img src="/mysql/b3.png" alt="pic"> <img src="/mysql/b4.png" alt="pic"> <img src="/mysql/b5.png" alt="pic"> <img src="/mysql/b6.png" alt="pic"></p> <h3 id="聚集索引-辅助索引"><a href="#聚集索引-辅助索引" aria-hidden="true" class="header-anchor">#</a> 聚集索引, 辅助索引</h3> <p>聚集索引以主键为索引, 存全部数据,
辅助索引, 以其他键为索引, 只存部分数据, 并给出主键,
完整数据还需要根据主键查找聚集索引,</p> <p>如果取大量数据, mysql也许不会使用索引,
或者有些列上没有建立索引,
此时, 就需要通过遍历的方式</p> <h3 id="联合索引"><a href="#联合索引" aria-hidden="true" class="header-anchor">#</a> 联合索引</h3> <p>两个以上列组成的索引,
排列时, 先比较第1位, 然后第2位 …</p> <h3 id="自适应哈希"><a href="#自适应哈希" aria-hidden="true" class="header-anchor">#</a> 自适应哈希</h3> <p>键值(主键或其他键)直接对于数据行,
自适应哈希主要是查找select * from xxtable where key=xxkey,
擅长精准查找, 但是不能范围查找</p> <h3 id="表"><a href="#表" aria-hidden="true" class="header-anchor">#</a> 表</h3> <h4 id="段"><a href="#段" aria-hidden="true" class="header-anchor">#</a> 段</h4> <p>todo,
段分为数据段, 索引段,
innodb存储引擎是索引组织的,
数据即索引, 索引即数据,
数据是b+树的叶节点, 索引是b+树的非叶节点</p> <h4 id="页"><a href="#页" aria-hidden="true" class="header-anchor">#</a> 页</h4> <p>mysql中先通过b+树找到记录所在的页,
然后在页中再利用page directory中通过二叉查找, 找到具体记录,</p> <h4 id="约束"><a href="#约束" aria-hidden="true" class="header-anchor">#</a> 约束</h4> <p>完整性
实体完整性, 保证唯一主键
域完整性, 保证值都是特定类型
参照完整性, 保证两张表间的外键关系,</p> <h4 id="触发器"><a href="#触发器" aria-hidden="true" class="header-anchor">#</a> 触发器</h4> <p>在insert/delete/update的before或after调用,
对数据进行检查,</p> <h3 id="锁"><a href="#锁" aria-hidden="true" class="header-anchor">#</a> 锁</h3> <p>mysql读取数据时, 对该数据记录一个版本号,
之后事务中, 每次都读取该版本号数据,
更新时, mysql会读取事务版本号和当前mysql中最新版本号,
相同, 则进行更新, 否则回滚失败,</p> <h4 id="死锁"><a href="#死锁" aria-hidden="true" class="header-anchor">#</a> 死锁</h4> <p>一个例子
t1: select a=1 for update, t1把1锁住,
t2: select a=2 for update, t2把2锁住,
t1: select a=2 for update, t1等待t2,
t2: select a=1 for update, t2等待t1</p> <h4 id="隔离级别"><a href="#隔离级别" aria-hidden="true" class="header-anchor">#</a> 隔离级别</h4> <p>读未提交： 可以及时读到及时数据
Read Uncommitted，顾名思义，就是一个事务可以读取另一个未提交事务的数据。最低级别，它存在 4 个常见问题（脏读、不可重复读、幻读、丢失更新）。</p> <p>读已提交： 读最新版历史数据
Read Committed，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。 它解决了脏读问题，存在 3 个常见问题（不可重复读、幻读、丢失更新）。</p> <p>可重复读： 读固定版历史数据
Repeatable Read，就是在开始读取数据（事务开启）时，不再允许修改操作 。它解决了脏读和不可重复读，还存在 2 个常见问题（幻读、丢失更新）。
丢失更新
mysql一般是可重复读的, 对于丢失更新, 它的解决方式是
读取历史版本数据时, 同时记录版本号,
在更新时, 如果版本号相同, 进行更新,
版本号不同, 更新失败,
幻读
事务select一个数据, 发现数据不存在, 插入时, 发现数据已存在,
大部分幻读是可以接受的,
要想避免可以使用select … for update,</p> <p>序列化： 完全顺序读
Serializable，序列化，或串行化。就是将每个事务按一定的顺序去执行，它将隔离问题全部解决，但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p> <h3 id="事务"><a href="#事务" aria-hidden="true" class="header-anchor">#</a> 事务</h3> <p>事务关注的是如何保证内存和磁盘的一致性
acid
原子性, 要么全做, 要么全不做
一致性, todo
隔离性, 客户端任何时刻都可以认为只有自己在操作
持久性, 只要事务返回成功, 那么它一定成功更新了数据库, 无论数据库之后是否挂了</p> <h4 id="重做日志"><a href="#重做日志" aria-hidden="true" class="header-anchor">#</a> 重做日志</h4> <p>redo log和undo log在功能上经常一起使用,
在理论上, 也都是事务日志的概念,
所以可以将二者视为同一日志,
不过redo log记录新值, 实现持久性,
undo log记录旧值, 实现原子性,</p> <p>ib_logfile0, ib_logfile1
记录了事务, 对于数据恢复非常重要
与二进制日志区别
二进制日志记录所有与mysql相关的内容, 以及具体操作,
而且在提交事务前记录
重做日志, 记录每个页改变的物理情况
在事务进行过程中, 不断提交</p> <p>重做日志从缓存刷向磁盘时, 在ib_logfile0和ib_logfile1之间循环写入</p> <h4 id="undo页"><a href="#undo页" aria-hidden="true" class="header-anchor">#</a> undo页</h4> <p>undo页记录了历史数据,
一个作用是事务读取数据时, 提供历史版本数据
另个作用是死锁时, 进行回滚</p> <p>undo记录的是逻辑信息,
比如对于每个insert记录一个delete,
对于每个update, 记录一个复原的update</p> <p>在事务commit后, 会被标记为无用的undo页,</p> <h4 id="wal"><a href="#wal" aria-hidden="true" class="header-anchor">#</a> WAL</h4> <p>在对数据修改前, 记录undo log, 修改后, 记录redo log,
事务提交前, 只向磁盘写redo log
undo log和数据都不向磁盘写, 这样可以减少io
当脏页刷入磁盘, redo log就没有用了,</p> <p>done, commit之后, undo不就没有意义了吗?
redo log只能追加, 并且为了io性能, 会多个事务写入同一日志,
因此会造成未提交事务也写入redo 日志,
在恢复时, 会重做所有redo log,
其中未记录commit的事务,
会通过undo log回滚,
理论上commit后, undo就没用了,
但由于mvcc, 其他事务可能还依赖undo信息,
所以需要等到undo信息没有引用后, 再释放,</p> <p>mysql的checkpoint记录了mysql的LSN(日志序号号),
恢复时从这个LSN开始即可
todo, checkpoint的时机</p> <h3 id="日志"><a href="#日志" aria-hidden="true" class="header-anchor">#</a> 日志</h3> <h4 id="二进制日志"><a href="#二进制日志" aria-hidden="true" class="header-anchor">#</a> 二进制日志</h4> <p>binlog在事务提交前, 一次性写入磁盘,
不像redo分次提交, 因此binlog会对io造成一定压力
理论上是先提交redo日志, 再提交binlog日志, 才算commit完成,
与二进制日志区别()</p> <h3 id="复制"><a href="#复制" aria-hidden="true" class="header-anchor">#</a> 复制</h3> <p>备机io线程从主机的二进制日志读取到relay log,
sql线程按照relay log写入数据库,</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">3/22/2020, 7:03:22 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/notes/vipserver.html" class="prev">
          Vipserver(天枢)
        </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.eaee92e7.js" defer></script><script src="/assets/js/2.3a03d1d4.js" defer></script><script src="/assets/js/10.ff8394e1.js" defer></script>
  </body>
</html>
